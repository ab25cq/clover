
#def GET_TYPE_FROM_C

/usr/bin/cat <<EOS > ~/.clover/tmpfiles/a.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
$PARAM0

int main()
{
    size_t size = sizeof($PARAM1);

    if(size == 1) {
        printf("byte");
    }
    else if(size == 2) {
        printf("short");
    }
    else if(size == 4) {
        printf("uint");
    }
    else if(size == 8) {
        printf("long");
    }
    else {
        exit(2);
    }

    exit(0);
}
EOS

/usr/bin/cc -o ~/.clover/tmpfiles/a.out ~/.clover/tmpfiles/a.c
~/.clover/tmpfiles/a.out
/usr/bin/rm -f ~/.clover/tmpfiles/a.c ~/.clover/tmpfiles/a.out
#enddef

#def DEFINE_CONSTRUCTOR_WITH_LONG

/usr/bin/cat <<EOS > ~/.clover/tmpfiles/a.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
$PARAM0

int main()
{
    size_t size = sizeof($PARAM1);

    if(size == 1) {
        printf("$PARAM2(long value) { self.setValue(value.toByte()); }");
    }
    else if(size == 2) {
        printf("$PARAM2(long value) { self.setValue(value.toShort()); }");
    }
    else if(size == 4) {
        printf("$PARAM2(long value) { self.setValue(value.toUInt()); }");
    }
    else if(size == 8) {
        /// pass ///
    }
    else {
        exit(2);
    }

    exit(0);
}
EOS

/usr/bin/cc -o ~/.clover/tmpfiles/a.out ~/.clover/tmpfiles/a.c
~/.clover/tmpfiles/a.out
/usr/bin/rm -f ~/.clover/tmpfiles/a.c ~/.clover/tmpfiles/a.out
#enddef

#def CALL_C_BLOCK
/usr/bin/mv $BLOCK_FILE ~/.clover/tmpfiles/a.c
/usr/bin/cc -o ~/.clover/tmpfiles/a.out ~/.clover/tmpfiles/a.c
~/.clover/tmpfiles/a.out
/usr/bin/rm -f  ~/.clover/tmpfiles/a.out ~/.clover/tmpfiles/a.c
#enddef

class dev_t extends
#call GET_TYPE_FROM_C #include\ <fcntl.h> dev_t
#endcall
{
    generics_newable dev_t(
#call GET_TYPE_FROM_C #include\ <fcntl.h> dev_t
#endcall
                          value)
    {
        self.setValue(value);
    }

#call DEFINE_CONSTRUCTOR_WITH_LONG #include\ <fcntl.h> dev_t dev_t
#endcall
}

class ino_t extends
#call GET_TYPE_FROM_C #include\ <fcntl.h> ino_t
#endcall
{
    generics_newable ino_t(
#call GET_TYPE_FROM_C #include\ <fcntl.h> ino_t
#endcall
                          value)
    {
        self.setValue(value);
    }

#call DEFINE_CONSTRUCTOR_WITH_LONG #include\ <fcntl.h> ino_t ino_t
#endcall
}

class mode_t extends
#call GET_TYPE_FROM_C #include\ <fcntl.h> mode_t
#endcall
{
    generics_newable mode_t (
#call GET_TYPE_FROM_C #include\ <fcntl.h> mode_t
#endcall
                          value)
    {
        self.setValue(value);
    }

#call DEFINE_CONSTRUCTOR_WITH_LONG #include\ <fcntl.h> mode_t mode_t
#endcall
}

class nlink_t extends
#call GET_TYPE_FROM_C #include\ <fcntl.h> nlink_t
#endcall
{
    generics_newable nlink_t (
#call GET_TYPE_FROM_C #include\ <fcntl.h> nlink_t
#endcall
                          value)
    {
        self.setValue(value);
    }

#call DEFINE_CONSTRUCTOR_WITH_LONG #include\ <fcntl.h> nlink_t nlink_t
#endcall
}

class uid_t extends
#call GET_TYPE_FROM_C #include\ <fcntl.h> uid_t
#endcall
{
    generics_newable uid_t (
#call GET_TYPE_FROM_C #include\ <fcntl.h> uid_t
#endcall
                          value)
    {
        self.setValue(value);
    }

#call DEFINE_CONSTRUCTOR_WITH_LONG #include\ <fcntl.h> uid_t uid_t
#endcall
}

class gid_t extends
#call GET_TYPE_FROM_C #include\ <fcntl.h> gid_t
#endcall
{
    generics_newable gid_t (
#call GET_TYPE_FROM_C #include\ <fcntl.h> gid_t
#endcall
                          value)
    {
        self.setValue(value);
    }

#call DEFINE_CONSTRUCTOR_WITH_LONG #include\ <fcntl.h> gid_t gid_t
#endcall
}

class off_t extends
#call GET_TYPE_FROM_C #include\ <fcntl.h> off_t
#endcall
{
    generics_newable off_t (
#call GET_TYPE_FROM_C #include\ <fcntl.h> off_t
#endcall
                          value)
    {
        self.setValue(value);
    }

#call DEFINE_CONSTRUCTOR_WITH_LONG #include\ <fcntl.h> off_t off_t
#endcall
}

class blksize_t extends
#call GET_TYPE_FROM_C #include\ <fcntl.h> blksize_t
#endcall
{
    generics_newable blksize_t (
#call GET_TYPE_FROM_C #include\ <fcntl.h> blksize_t
#endcall
                          value)
    {
        self.setValue(value);
    }

#call DEFINE_CONSTRUCTOR_WITH_LONG #include\ <fcntl.h> blksize_t blksize_t
#endcall
}

class blkcnt_t extends
#call GET_TYPE_FROM_C #include\ <fcntl.h> blkcnt_t
#endcall
{
    generics_newable blkcnt_t (
#call GET_TYPE_FROM_C #include\ <fcntl.h> blkcnt_t
#endcall
                          value)
    {
        self.setValue(value);
    }

#call DEFINE_CONSTRUCTOR_WITH_LONG #include\ <fcntl.h> blkcnt_t blkcnt_t
#endcall
}

class time_t extends
#call GET_TYPE_FROM_C #include\ <fcntl.h> time_t
#endcall
{
    generics_newable time_t (
#call GET_TYPE_FROM_C #include\ <fcntl.h> time_t
#endcall
                          value)
    {
        self.setValue(value);
    }

#call DEFINE_CONSTRUCTOR_WITH_LONG #include\ <fcntl.h> time_t time_t
#endcall
}

class pid_t extends
#call GET_TYPE_FROM_C #include\ <unistd.h> pid_t
#endcall
{
    generics_newable pid_t (
#call GET_TYPE_FROM_C #include\ <unistd.h> pid_t
#endcall
                          value)
    {
        self.setValue(value);
    }

#call DEFINE_CONSTRUCTOR_WITH_LONG #include\ <unistd.h> pid_t pid_t
#endcall
}

class WaitStatus extends int
{
    generics_newable WaitStatus(int status) {
        self.setValue(status);
    }

    native bool exited();
    native int exitStatus();
    native bool signaled();
    native int signalNumber();
}

mixin struct uint version 2
{
}

mixin struct long version 2
{
    FileKind toFileKind() {
        return new FileKind(self);
    }

    FileAccess toFileAccess() {
        return new FileAccess(self);
    }

    dev_t to_dev_t() {
        return new dev_t(self);
    }

    ino_t to_ino_t() {
        return new ino_t(self);
    }

    mode_t to_mode_t() {
        return new mode_t(self);
    }

    nlink_t to_nlink_t() {
        return new nlink_t(self);
    }

    uid_t to_uid_t() {
        return new uid_t(self);
    }

    gid_t to_gid_t() {
        return new gid_t(self);
    }

    off_t to_off_t() {
        return new off_t(self);
    }

    blksize_t to_blksize_t() {
        return new blksize_t(self);
    }

    blkcnt_t to_blkcnt_t() {
        return new blkcnt_t(self);
    }

    time_t to_time_t() {
        return new time_t(self);
    }
}

enum AccessMode extends int
{
    F_OK, R_OK, W_OK, X_OK
}

class AccessMode
{
    generics_newable AccessMode(int value) {
        self.setValue(value);
    }
    static bool initialize() {
        AccessMode.F_OK, AccessMode.R_OK, AccessMode.W_OK, AccessMode.X_OK = 
#call CALL_C_BLOCK
#include <stdlib.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>

int main(int argc, char* argv[]) {
    printf("%d.toAccessMode(), %d.toAccessMode(), %d.toAccessMode(), %d.toAccessMode();", F_OK, R_OK, W_OK, X_OK);

    exit(0);
}
#endcall

        return true;
    }
}

class utimbuf 
{
    time_t actime;
    time_t modtime;

    utimbuf(time_t actime, time_t modtime) {
        self.actime = actime;
        self.modtime = modtime;
    }
}

enum FileLockOperation extends int
{
    LOCK_SH, LOCK_EX, LOCK_UN, LOCK_NB
}

class FileLockOperation
{
    generics_newable FileLockOperation(int value) {
        self.setValue(value);
    }

    static bool initialize() {
        FileLockOperation.LOCK_SH, FileLockOperation.LOCK_EX, FileLockOperation.LOCK_UN, FileLockOperation.LOCK_NB = 
#call CALL_C_BLOCK
#include <stdlib.h>
#include <stdio.h>
#include <sys/file.h>

int main(int argc, char* argv[]) {
    printf("%d.toFileLockOperation(), %d.toFileLockOperation(), %d.toFileLockOperation(), %d.toFileLockOperation();", LOCK_SH, LOCK_EX, LOCK_UN, LOCK_NB);

    exit(0);
}
#endcall
        return true;
    }
}

enum FnmatchFlags extends int
{
    FNM_NOESCAPE, FNM_PATHNAME, FNM_PERIOD, FNM_LEADING_DIR, FNM_CASEFOLD
}

class FnmatchFlags
{
    generics_newable FnmatchFlags(int value) {
        self.setValue(value);
    }

    static bool initialize() {
        FnmatchFlags.FNM_NOESCAPE, FnmatchFlags.FNM_PATHNAME, FnmatchFlags.FNM_PERIOD, FnmatchFlags.FNM_LEADING_DIR, FnmatchFlags.FNM_CASEFOLD = 
#call CALL_C_BLOCK
#include <stdlib.h>
#include <stdio.h>
#define _GNU_SOURCE
#include <fnmatch.h>

int main(int argc, char* argv[]) {
    printf("%d.toFnmatchFlags(), %d.toFnmatchFlags(), %d.toFnmatchFlags(), %d.toFnmatchFlags(), %d.toFnmatchFlags();", FNM_NOESCAPE, FNM_PATHNAME, FNM_PERIOD, FNM_LEADING_DIR, FNM_CASEFOLD);

    exit(0);
}
#endcall
        return true;
    }
}

class DIR extends pointer
{
    generics_newable DIR(pointer value) {
        self.setValue(value);
    }
}

class dirent
{
    pointer c_dirent_value;
    Bytes d_name;

    virtual bool operator==(dirent@Nullable value) {
        if(self.type() == Null || value.type() == Null) {
            return self.type() == Null && value.type() == Null;
        }

        return self.c_dirent_value == value.c_dirent_value && self.d_name == value.d_name;
    }

    virtual bool operator!=(dirent@Nullable value) {
        return !(self == value);
    }
}

mixin class System version 2
{
    native static Path getcwd();
    native static void execv(String command, Array<String> params) throws ConvertingStringCodeException, SystemException;
    native static void execvp(String command, Array<String> params) throws ConvertingStringCodeException, SystemException;
    native static int fork() with void block() throws Exception, SystemException;
    native static int dup2(int fd1, int fd2) throws SystemException;
    native static int pipe(int* read_fd, int* write_fd) throws SystemException;
    native static int getpid();
    native static int getppid();
    native static int getpgid(int pid) throws SystemException;
    native static void setpgid(int pid, int pgid) throws SystemException;
    native static void tcsetpgrp(int fd, int pgid) throws SystemException;
    native static int close(int fd) throws SystemException;
    native static Tuple<pid_t,WaitStatus> wait() throws SystemException;  // result is Tuple<pid,status>
    native static int open(Path file_name, FileMode mode, int permission=0644) throws SystemException;
    native static int write(int fd, Bytes data) throws SystemException;
    native static int read(int fd, Bytes data, int size) throws SystemException;

    native static void stat(Path path, stat buf) throws SystemException;
    native static void lstat(Path path, stat buf) throws SystemException;
    native static time_t time();
    native static Path basename(Path path);
    native static Path dirname(Path path);
    native static void chmod(Path path, mode_t mode) throws SystemException;
    native static void lchmod(Path path, mode_t mode) throws SystemException;
    native static void chown(Path path, uid_t owner, gid_t group) throws SystemException;
    native static void lchown(Path path, uid_t owner, gid_t group) throws SystemException;
    native static uid_t getuid();
    native static gid_t getgid();
    native static void unlink(Path path) throws SystemException;

    /// the result is return value and err message //
    native static Tuple<int,String> access(Path path, AccessMode mode);

    native static void utime(Path path, utimbuf@Nullable times) throws SystemException;
    native static time_t mktime(tm time) throws SystemException;
    native static bool fnmatch(String pattern, Path path, FnmatchFlags flags) throws SystemException;
    native static void link(Path oldpath, Path newpath) throws SystemException;
    native static void symlink(Path oldpath, Path newpath) throws SystemException;
    native static Path readlink(Path path) throws SystemException;
    native static void rename(Path oldname, Path newname) throws SystemException;
    native static void truncate(Path path, off_t length) throws SystemException;
    native static mode_t umask(mode_t mask);
    native static void flock(int fd, FileLockOperation operation) throws SystemException;
    native static DIR opendir(Path path) throws SystemException;
    native static dirent@Nullable readdir(DIR dir) throws SystemException;
    native static void closedir(DIR dir) throws SystemException;
    native static void chdir(Path path) throws SystemException;
}

mixin class String version 2
{
    Command toCommand() {
        return new Command(self, 0);
    }

    Path toPath() {
        return new Path(self);
    }
}

class tm
{
    protected int tm_sec;
    protected int tm_min;
    protected int tm_hour;
    protected int tm_mday;
    protected int tm_mon;
    protected int tm_year;
    protected int tm_wday;
    protected int tm_yday;
    protected bool tm_isdst;

    native tm(time_t time);

    tm(int year, int month, int day_of_month, int hour=0, int minuts=0, int sec=0, int day_of_week=0, int day_of_year=0, bool isdst=false)
    {
        self.setYear(year);
        self.setMonth(month);
        self.setDayOfMonth(day_of_month);
        self.setHour(hour);
        self.setMinuts(minuts);
        self.setSecond(sec);
        self.setDayOfWeek(day_of_week);
        self.setDayOfYear(day_of_year);
        self.setDaylightSavingTime(isdst);
    }

    int second() {
        return self.tm_sec;
    }
    void setSecond(int value) {
        self.tm_sec = value;
    }
    int minuts() {
        return self.tm_min;
    }
    void setMinuts(int value) {
        self.tm_min = value;
    }
    int hour() {
        return self.tm_hour;
    }
    void setHour(int value) {
        self.tm_hour = value;
    }
    int dayOfMonth() {
        return self.tm_mday;
    }
    void setDayOfMonth(int value) {
        self.tm_mday = value;
    }
    int month() {
        return self.tm_mon + 1;
    }
    void setMonth(int value) {
        self.tm_mon = value -1;
    }
    int year() {
        return self.tm_year + 1900;
    }
    void setYear(int value) {
        self.tm_year = value - 1900;
    }
    int dayOfWeek() {
        return self.tm_wday;
    }
    void setDayOfWeek(int value) {
        self.tm_wday = value;
    }
    int dayOfYear() {
        return self.tm_yday;
    }
    void setDayOfYear(int value) {
        self.tm_yday = value;
    }
    bool isDaylightSavingTime() {
        return self.tm_isdst;
    }
    void setDaylightSavingTime(bool value) {
        self.tm_isdst = value;
    }

    virtual String toString() {
        return sprintf("%d-%02d-%02d %02d:%02d", self.year(), self.month(), self.dayOfMonth(), self.hour(), self.minuts());
    }

    time_t to_time_t() throws SystemException{
        return System.mktime(self);
    }
}

mixin class Clover version 2
{
    alias printf;
    alias sprintf;

    /// called at the first part of runtime ///
    mixin static bool initialize() {
        bool result = mixin();
        if(result == false) {
            return false;
        }

        System.srand(System.time().toInt());

        String clover_home = System.getenv("HOME") + "/.clover/";

        System.system("/usr/bin/rm -Rf " + clover_home + "tmpfiles/*");

        return true;
    }
    native static String sprintf(String format, Array<anonymous> params, ...);
    native static void printf(String format, Array<anonymous> params, ...);
}

enum FileMode extends int
{
    O_APPEND, O_ASYNC, O_CLOEXEC, O_CREAT, O_DIRECTORY, O_DSYNC, O_EXCL, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY
}

class FileMode 
{
    generics_newable FileMode(int value) {
        self.setValue(value);
    }

    static bool initialize() {
        FileMode.O_APPEND, FileMode.O_ASYNC, FileMode.O_CLOEXEC, FileMode.O_CREAT, FileMode.O_DIRECTORY, FileMode.O_DSYNC, FileMode.O_EXCL = 
#call CALL_C_BLOCK
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[]) {
    printf("%d.toFileMode(), %d.toFileMode(), %d.toFileMode(), %d.toFileMode(), %d.toFileMode(), %d.toFileMode(), %d.toFileMode(), %d.toFileMode();", O_APPEND, O_ASYNC, O_CLOEXEC, O_CREAT, O_DIRECTORY, O_DSYNC, O_EXCL);
    exit(0);
}
#endcall
        FileMode.O_NOCTTY, FileMode.O_NOFOLLOW, FileMode.O_NONBLOCK, FileMode.O_RDONLY, FileMode.O_RDWR, FileMode.O_SYNC, FileMode.O_TRUNC, FileMode.O_WRONLY = 
#call CALL_C_BLOCK
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[]) {
    printf("%d.toFileMode(), %d.toFileMode(), %d.toFileMode(), %d.toFileMode(), %d.toFileMode(), %d.toFileMode(), %d.toFileMode(), %d.toFileMode();",  O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY);
    exit(0);
}
#endcall

        return true;
    }
}

enum FileKind extends mode_t 
{
    S_IFMT, S_IFDIR, S_IFCHR, S_IFBLK, S_IFREG, S_IFIFO, S_IFLNK, S_IFSOCK
}

class FileKind
{
    generics_newable FileKind (
#call GET_TYPE_FROM_C #include\ <fcntl.h> mode_t
#endcall
                          value)
    {
        self.setValue(value);
    }

#call DEFINE_CONSTRUCTOR_WITH_LONG #include\ <fcntl.h> mode_t FileKind
#endcall

    static bool initialize() {
        FileKind.S_IFMT, FileKind.S_IFDIR, FileKind.S_IFCHR, FileKind.S_IFBLK, FileKind.S_IFREG, FileKind.S_IFIFO, FileKind.S_IFLNK, FileKind.S_IFSOCK = 
#call CALL_C_BLOCK
#include <sys/stat.h>
#include <stdlib.h>
#include <stdio.h>

int main() {
    printf("%dl.toFileKind(), %dl.toFileKind(), %dl.toFileKind(), %dl.toFileKind(), %dl.toFileKind(), %dl.toFileKind(), %dl.toFileKind(), %dl.toFileKind();", S_IFMT, S_IFDIR, S_IFCHR, S_IFBLK, S_IFREG, S_IFIFO, S_IFLNK, S_IFSOCK);

    exit(0);
}

#endcall

        return true;
    }
}

enum FileAccess extends mode_t 
{
    S_ISUID, S_ISGID, S_ISVTX, S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG, S_IRGRP, S_IWGRP, S_IXGRP, S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH
}

class FileAccess
{
    generics_newable FileAccess (
#call GET_TYPE_FROM_C #include\ <fcntl.h> mode_t
#endcall
                          value)
    {
        self.setValue(value);
    }

#call DEFINE_CONSTRUCTOR_WITH_LONG #include\ <fcntl.h> mode_t FileAccess
#endcall

    static bool initialize() {
        FileAccess.S_ISUID, FileAccess.S_ISGID, FileAccess.S_ISVTX, FileAccess.S_IRWXU, FileAccess.S_IRUSR, FileAccess.S_IWUSR, FileAccess.S_IXUSR, FileAccess.S_IRWXG = 
#call CALL_C_BLOCK
#include <sys/stat.h>
#include <stdlib.h>
#include <stdio.h>

int main() {
    printf("%dl.toFileAccess(), %dl.toFileAccess(), %dl.toFileAccess(), %dl.toFileAccess(), %dl.toFileAccess(), %dl.toFileAccess(), %dl.toFileAccess(), %dl.toFileAccess();", S_ISUID, S_ISGID, S_ISVTX, S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG);

    exit(0);
}
#endcall

        FileAccess.S_IRGRP, FileAccess.S_IWGRP, FileAccess.S_IXGRP, FileAccess.S_IRWXO, FileAccess.S_IROTH, FileAccess.S_IWOTH, FileAccess.S_IXOTH = 
#call CALL_C_BLOCK
#include <sys/stat.h>
#include <stdlib.h>
#include <stdio.h>

int main() {
    printf("%dl.toFileAccess(), %dl.toFileAccess(), %dl.toFileAccess(), %dl.toFileAccess(), %dl.toFileAccess(), %dl.toFileAccess(), %dl.toFileAccess();", S_IRGRP, S_IWGRP, S_IXGRP, S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH);

    exit(0);
}
#endcall

        return true;
    }
}

class stat
{
    dev_t st_dev;
    ino_t st_ino;
    mode_t st_mode;
    nlink_t st_nlink;
    uid_t st_uid;
    gid_t st_gid;
    dev_t st_rdev;
    off_t st_size;
    blksize_t st_blksize;
    blkcnt_t st_blocks;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;

    stat(Path path, bool lstat=false) throws SystemException {
        if(lstat) {
            System.lstat(path, self);
        }
        else {
            System.stat(path, self);
        }
    }
    bool S_ISDIR() {
        return (self.st_mode & FileKind.S_IFMT) == FileKind.S_IFDIR;
    }
    bool S_ISCHR() {
        return (self.st_mode & FileKind.S_IFMT) == FileKind.S_IFCHR;
    }
    bool S_ISBLK() {
        return (self.st_mode & FileKind.S_IFMT) == FileKind.S_IFBLK;
    }
    bool S_ISREG() {
        return (self.st_mode & FileKind.S_IFMT) == FileKind.S_IFREG;
    }
    bool S_ISFIFO() {
        return (self.st_mode & FileKind.S_IFMT) == FileKind.S_IFIFO;
    }
    bool S_ISLNK() {
        return (self.st_mode & FileKind.S_IFMT) == FileKind.S_IFLNK;
    }
    bool S_ISSOCK() {
        return (self.st_mode & FileKind.S_IFMT) == FileKind.S_IFSOCK;
    }
    uid_t uid() {
        return self.st_uid;
    }
    gid_t gid() {
        return self.st_gid;
    }
    mode_t permission() {
        return self.st_mode & (FileAccess.S_ISUID|FileAccess.S_ISGID|FileAccess.S_ISVTX|FileAccess.S_IRWXU|FileAccess.S_IRWXG|FileAccess.S_IRWXO);
    }
    tm atime() {
        return new tm(self.st_atime);
    }
    tm ctime() {
        return new tm(self.st_ctime);
    }
    tm mtime() {
        return new tm(self.st_mtime);
    }
}

class Path extends String
{
    Path(String value) {
        self.setValue(value);
    }

    virtual String toString() {
        String result = new String("");
        result.setValue(self);
        return result;
    }

    void toFile(String mode="r", int permission=0666) with void block(File file) throws Exception, SystemException
    {
        File.open(self, mode, permission) with block;
    }

    void write(Bytes data, int permission=0666) throws SystemException, Exception {
        File f = File.open(self, "w", permission);
        f.write(data);
        f.close();
    }

    Bytes readOut(int permission=0666) throws SystemException, Exception 
    {
        File f = File.open(self, "r", permission);
        Bytes result = f.readOut();
        f.close();

        return result;
    }

    stat to_stat() {
        return new stat(self, false);
    }
    stat to_lstat() {
        return new stat(self, true);
    }
    Path basename(String suffix=null) {
        Path result = System.basename(self);

        if(suffix == ".*") {
            int index = result.rindex(/\./);

            if(index != -1) {
                result = result[0..index].toPath();
            }
        }
        else if(suffix != null) {
            int index = result.rindex(suffix);

            if(index != -1 && index == result.length() - suffix.length()) {
                result = result[0..index].toPath();
            }
        }

        return result;
    }

    Path dirname() {
        return System.dirname(self);
    }

    Path extname() {
        int index = self.rindex(".");
        Path dirname = self.dirname();

        if(index == -1 || index == 0 || self[index-1] == '/' 
            || index < dirname.length()) 
        {
            return p"";
        }
        else {
            return self[index..null].toPath();
        }
    }

    void chmod(mode_t mode) throws SystemException {
        System.chmod(self, mode);
    }
    void lchmod(mode_t mode) throws SystemException {
        System.lchmod(self, mode);
    }
    void chown(uid_t owner=-1l.to_uid_t(), gid_t group=-1l.to_gid_t()) throws SystemException 
    {
        System.chown(self, owner, group);
    }
    void lchown(uid_t owner=-1l.to_uid_t(), gid_t group=-1l.to_gid_t()) throws SystemException 
    {
        System.lchown(self, owner, group);
    }
    void unlink() throws SystemException {
        System.unlink(self);
    }
    int access(AccessMode mode=AccessMode.F_OK) {
        return System.access(self, mode).get1();
    }
    bool isExist() {
        return self.access(AccessMode.F_OK) == 0;
    }
    void utime(time_t actime, time_t modtime) {
        System.utime(self, new utimbuf(actime, modtime));
    }

    bool fnmatch(String pattern, FnmatchFlags flags=0.toFnmatchFlags()) {
        return System.fnmatch(pattern, self, flags);
    }

    bool isIdentical(Path path2) {
        return self.absolutePath() == path2.absolutePath();
    }

    Path absolutePath() {
        String result = self.clone();

        /// add current path to head ///
        if(result[0] != '/') {
            result = System.getcwd() + "/" + result;
        }

        /// delete ./ ///
        result = result.sub(/(\/\.)($|\/)/g) {
            |Array<String> group_strings, String prematch, String match, String postmatch|
            if(group_strings.length() == 2) {
                if(group_strings[1] == "/") {
                    return "/";
                }
            }

            return "";
        };

        /// delete .. ///
        result = result.sub(/^(\/\.\.)+($|\/)/) {
            |Array<String> group_strings, String prematch, String match, String postmatch|
            if(group_strings.length() == 2) {
                if(group_strings[1] == "/") {
                    return "/";
                }
            }

            return "";
        }

        result = result.sub(/(\/[^\/]+)(\/\.\.)($|\/)/g) {
            |Array<String> group_strings, String prematch, String match, String postmatch|

            if(group_strings.length() == 3) {
                if(group_strings[2] == "/") {
                    return "/";
                }
            }
            
            return "";
        }

        /// Is this path directory? If that is true, append / to the tail. If that is false, remove '/' at the tail  ///
        bool is_directory = false;
        try {
            is_directory = result.toPath().to_stat().S_ISDIR();
        }
        catch(SystemException e) {
            if(result[-1] == '/') {
                try {
                    is_directory = result[0..-1].toPath().to_stat().S_ISDIR();
                }
                catch(SystemException e) {
                    is_directory = false;
                }
            }
        }

        if(is_directory) {
            if(result[-1] != '/') {
                result += "/";
            }
        }
        else {
            if(result[-1] == '/') {
                result = result[0..-1];
            }
        }

        if(result == "") {
            result = "/";
        }
        
        return result.toPath();
    }

    void link(Path newpath) throws SystemException {
        System.link(self, newpath);
    }

    void symlink(Path newpath) throws SystemException {
        System.symlink(self, newpath);
    }

    Path readlink() throws SystemException {
        return System.readlink(self);
    }

    void rename(Path path) throws SystemException {
        System.rename(self, path);
    }

    void truncate(off_t length) throws SystemException {
        System.truncate(self, length);
    }

    Array<String> entries() throws SystemException {
        return Directory.entries(self);
    }

    Array<String> glob(String pattern, FnmatchFlags flags=0.toFnmatchFlags()) throws SystemException
    {
        return Directory.glob(self, pattern, flags);
    }

    void chdir() throws SystemException {
        System.chdir(self);
    }
}

mixin struct int version 2
{
    AccessMode toAccessMode() {
        return new AccessMode(self);
    }
    FnmatchFlags toFnmatchFlags() {
        return new FnmatchFlags(self);
    }
    FileLockOperation toFileLockOperation() {
        return new FileLockOperation(self);
    }
    FileMode toFileMode() {
        return new FileMode(self);
    }
}

abstract class FileBase 
{
    int descriptor;

    abstract int write(Bytes data) throws IOException, Exception;
    abstract int read(Bytes data, int size) throws IOException;
}

class File extends FileBase
{
    Path path;

    File(Path path, String mode="r", int permission=0666) throws Exception, SystemException {
        if(mode == "w") {
            self.descriptor = System.open(path, (FileMode.O_CREAT|FileMode.O_WRONLY|FileMode.O_TRUNC).toFileMode(), permission);
        }
        else if(mode == "w+") {
            self.descriptor = System.open(path, (FileMode.O_RDWR|FileMode.O_CREAT|FileMode.O_TRUNC).toFileMode(), permission);
        }
        else if(mode == "r") {
            self.descriptor = System.open(path, FileMode.O_RDONLY, permission);
        }
        else if(mode == "r+") {
            self.descriptor = System.open(path, FileMode.O_RDWR, permission);
        }
        else if(mode == "a") {
            self.descriptor = System.open(path, (FileMode.O_WRONLY|FileMode.O_CREAT|FileMode.O_APPEND).toFileMode(), permission);
        }
        else if(mode == "a+") {
            self.descriptor = System.open(path, (FileMode.O_RDWR|FileMode.O_CREAT|FileMode.O_APPEND).toFileMode(), permission);
        }
        else {
            throw new Exception("invalid mode");
        }

        self.path = path;
    }

    static File open(Path path, String mode="r", int permission=0666) {
        return new File(path, mode, permission);
    }

    static void open(Path path, String mode="r", int permission=0666) with void block(File file) throws Exception, SystemException
    {
        File file = new File(path, mode, permission);
        block(file);
        file.close();
    }

    virtual int write(Bytes data) throws SystemException, Exception {
        if(self.descriptor == null) {
            throw new Exception("This file is not opened");
        }

        return System.write(self.descriptor, data);
    }
    virtual int read(Bytes data, int size) throws SystemException, Exception {
        if(self.descriptor == null) {
            throw new Exception("This file is not opened");
        }

        return System.read(self.descriptor, data, size);
    }

    int close() throws SystemException, Exception {
        if(self.descriptor == null) {
            throw new Exception("This file is not opened");
        }

        return System.close(self.descriptor);
    }

    static mode_t umask() {
        mode_t mask = System.umask(0l.to_mode_t());
        System.umask(mask);
        return mask;
    }

    static void umask(mode_t mask) {
        System.umask(mask);
    }

    void flock(FileLockOperation operation) throws SystemException,Exception {
        if(self.descriptor == null) {
            throw new Exception("This file is not opened");
        }

        System.flock(self.descriptor, operation);
    }

    Path toPath() throws Exception {
        if(self.path == null) {
            throw new Exception("This file is not opened");
        }

        return self.path;
    }

    stat to_stat() throws Exception {
        if(self.path == null) {
            throw new Exception("This file is not opened");
        }

        return self.path.to_stat();
    }

    Bytes readOut() throws SystemException, Exception {
        if(self.descriptor == null) {
            throw new Exception("This file is not opened");
        }

        Bytes result = B"";

        while(true) {
            Bytes buf = B"";

            System.read(self.descriptor, buf, 1024@size);

            result += buf;

            if(buf.length() < 1024) {
                break;
            }
        }

        return result;
    }
}

class Directory
{
    Path path;
    DIR dir;

    Directory(Path path) throws SystemException {
        self.path = path;
        self.dir = System.opendir(path);
    }

    String@Nullable readdir() throws SystemException, Exception {
        if(self.dir == null) {
            throw new Exception("This directory is not opened");
        }

        dirent entry = System.readdir(self.dir);

        if(entry == null) {
            return null;
        }
        else {
            return entry.d_name.toString();
        }
    }

    void close() throws Exception {
        if(self.dir == null) {
            throw new Exception("This directory is not opened");
        }

        System.closedir(self.dir);
    }

    static Array<String> entries(Path path) throws SystemException {
        Directory dir = new Directory(path);
        Array<String> result = new Array<String>();

        while(true) {
            String entry = dir.readdir();

            if(entry == null) {
                break;
            }

            result.add(entry);
        }
        dir.close();

        return result;
    }

    static Array<String> glob(Path path, String pattern, FnmatchFlags flags=0.toFnmatchFlags()) throws SystemException
    {
        Directory dir = new Directory(path);
        Array<String> result = new Array<String>();

        while(true) {
            String entry = dir.readdir();

            if(entry == null) {
                break;
            }

            if(System.fnmatch(pattern, entry.toPath(), flags)) {
                result.add(entry);
            }
        }
        dir.close();

        return result;
    }
}

dynamic_typing final class Command implements IInspectable 
{
    protected String data;
    protected int resultCode;

    static Array<String> controllingTerminalPrograms = { "vim", "less", "top", "lv", "htop", "emacs", "nano", "vi", "fd", "mc" };

    Command() {
        self.data = "";
        self.resultCode = 0;
    }

    Command(String data, int result_code) {
        self.data = data;
        self.resultCode = result_code;
    }

    int resultCode() {
        return self.resultCode;
    }

    virtual String toString() {
        return self.data;
    }

    static Command excuteCommandWithControllingTerminalByPipe(String method_name, Array<anonymous> params, Block method_block, String pipe_data)
    {
        int parent2child_write_fd = 0;
        int parent2child_read_fd = 0;

        System.pipe(parent2child_read_fd, parent2child_write_fd);

        int pid = System.fork() {
            System.close(parent2child_write_fd);

            int pid = System.getpid();

            System.setpgid(0, 0);
            System.tcsetpgrp(0, pid);

            System.dup2(parent2child_read_fd, 0);
            System.close(parent2child_read_fd);

            try {
                System.execvp(method_name, params.select() {|anonymous param| return String->substitutionPosibility(param.type()); } );
            } catch(SystemException e) {
                System.write(2, (e.getMessage() + "\n").toBytes());
                System.exit(2);
            }
        }

        System.setpgid(pid, pid);
        System.tcsetpgrp(0, pid);

        System.close(parent2child_read_fd);

        if(pipe_data != null) {
            System.write(parent2child_write_fd, pipe_data.toBytes());
        }
        System.close(parent2child_write_fd);

        pid_t pid2, WaitStatus status = System.wait();

        System.tcsetpgrp(0, System.getpid());

        return new Command("", status.exitStatus());
    }

    static Command excuteCommandWithControllingTerminal(String method_name, Array<anonymous> params, Block method_block)
    {
        int pid = System.fork() {
            int pid = System.getpid();

            System.setpgid(0, 0);
            System.tcsetpgrp(0, pid);

            try {
                System.execvp(method_name, params.select() {|anonymous param| return String->substitutionPosibility(param.type()); } );
            } catch(SystemException e) {
                System.write(2, (e.getMessage() + "\n").toBytes());
                System.exit(2);
            }
        }

        System.setpgid(pid, pid);
        System.tcsetpgrp(0, pid);

        pid_t pid2, WaitStatus status = System.wait();

        System.tcsetpgrp(0, System.getpid());

        return new Command("", status.exitStatus());
    }

    static Command executeCommand(String method_name, Array<anonymous> params, Block method_block, String pipe_data) 
    {
        int child2parent_write_fd = 0;
        int child2parent_read_fd = 0;
        int parent2child_write_fd = 0;
        int parent2child_read_fd = 0;

        System.pipe(child2parent_read_fd, child2parent_write_fd);
        System.pipe(parent2child_read_fd, parent2child_write_fd);

        System.fork() {
            System.close(parent2child_write_fd);
            System.close(child2parent_read_fd);

            System.dup2(parent2child_read_fd, 0);
            System.dup2(child2parent_write_fd, 1);

            System.close(parent2child_read_fd);
            System.close(child2parent_write_fd);

            try {
                System.execvp(method_name, params.select() {|anonymous param| return String->substitutionPosibility(param.type()); } );
            } catch(SystemException e) {
                System.write(2, (e.getMessage() + "\n").toBytes());
                System.exit(2);
            }
        }

        System.close(parent2child_read_fd);
        System.close(child2parent_write_fd);

        if(pipe_data != null) {
            System.write(parent2child_write_fd, pipe_data.toBytes());
        }
        System.close(parent2child_write_fd);

        Bytes child_output = B"";
        
        while(true) {
            Bytes pipe_data = B"";

            int readed_byte = System.read(child2parent_read_fd, pipe_data, 10);

            if(readed_byte == 0) {
                break;
            }

            child_output += pipe_data;
        }

        System.close(child2parent_read_fd);

        pid_t pid, WaitStatus status = System.wait();

        return new Command(child_output.toString(), status.exitStatus());
    }

    static Command methodMissing(String method_name, Array<anonymous> params, Block method_block) 
    {
        if(Command.controllingTerminalPrograms.include(method_name)) {
            return Command.excuteCommandWithControllingTerminal(method_name, params, method_block);
        }
        else {
            return Command.executeCommand(method_name, params, method_block, null);
        }
    }

    Command methodMissing(String method_name, Array<anonymous> params, Block method_block)
    {
        if(Command.controllingTerminalPrograms.include(method_name)) {
            return Command.excuteCommandWithControllingTerminalByPipe(method_name, params, method_block, self.data);
        }
        else {
            return Command.executeCommand(method_name, params, method_block, self.data);
        }
    }

/*
    Tuple<Array<String>, Type> completion(String method_name)
    {
        Array<String> result = new Array<String>();

        String env_path = System.getenv("PATH");
        String path = "";

        for(int offset = 0; offset<env_path.length(); offset++) {
            if(env_path[offset] == ':') {
                if(File.isDirectory(path)) {
                    new Directory(path).each() {|String file_name|
                        result.append(file_name);
                    }
                }

                path = "";
            }
            else {
                path += env_path[offset].toCharacter();
            }
        }

        if(File.isDirectory(path)) {
            new Directory(path).each() {|String file_name|
                result.append(file_name);
            }
        }

        return result, Command;
    }
*/
}
