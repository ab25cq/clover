-+- 仕様 -+------------------------------------------------------
[オブジェクトを作成する手順]

1. createするオブジェクトは必ず一度ローカル変数に入れてください。

    CLObject obj;
    obj = create_bool_object(1);

2. 複数回オブジェクトを作成する時は、前に作成したオブジェクトはマークされるようにしないとダメです。スタックにpushするか、他のマークされるオブジェクトに格納するかしてください。スタックにpush後はマークされることが確定されれば、pop_objectしてください。マークされない状態でGCが動くと消えてしまいます。

    CLObject obj1, obj2;

    obj = create_bool_object(1);

    push_object(obj, info);        // -->マークのためスタックに退避しておく。(= objはマークされる)

    obj2 = create_bool_object(2);  // -->ここでGCが動く可能性がある。

    // obj2やobjを次回のGCが動くまで(オブジェクトを作成するときまで)にマークされる状態にする。

    pop_object(info);

    // obj2やobjを次回のGCが動くまで(オブジェクトを作成するときまで)にマークされる状態にする。


int型は32/64ビット. CPUのビット数依存。
Stringの1文字はwchar_t型。 Stringはwchar_tの配列として扱っている。
wchar_tはUTF-32らしい。(== 32ビット)
'a'1文字もint型として扱っている。

superはクラスメソッドには対応していない

ブロックにはresult typeを最初に書く。
int a = int {
    111;
}

void {
    Clover.println("HELLO BLOCK");
}

immediate value class --> void, int, float, bool, null
special class --> Array, Hash, String
どちらもフィールドが追加できない。
継承したクラスでもフィールドが追加できない。-->special classは追加できるようにする。

すべてのクラスはopen class。フィールドとメソッドの追加に何の制限もない。追加する場合はソースをincludeしてmixin指定をclass名の最初につける。ただし、フィールドとメソッドのindexはコンパイル時に決まるので、追加した場合は既存のソースの再コンパイルが必要になることがある。その辺はユーザーが管理する。その代わりメソッドの探索はコンパイル時に決まるため、実行時には不要。polymophizmが必要な場合はvirtual指定して実行時にメソッド探索する。

クラスの参照はクラスファイル単位。includeは単に同一ファイルとして扱って同時にコンパイルするだけ。循環参照のためにある。クラスの依存関係は、ユーザーの管理。

ヒープに関する仕様。

ヒープからメモリを取り出し、あるマークされる変数に代入する前に、さらにヒープからメモリを取り出すと、最初のメモリが開放されてしまう。2度目以上のメモリを取り出す前に最初のメモリをpush_objectしてスタックに積む必要がある。後片付けとしてpop_objectも必要。

左辺にヒープのトップからのoffset、右辺にGC(realloc)が起こり得る関数がくる代入はC言語の仕様により、代入がおかしくなる。
一度右辺の値をCLObjectに代入してから左辺のoffset位置に代入する必要がある。
(今のところの仕様。GCを書き直して直るかもしれない)

newは引数なしなら、コンストラクタを定義していなくても呼べる。すべて0が入っている。

ヒープ(GCが走る可能性があるobjectの生成など)を使うところにはthreadのlockが必要。

オブジェクトが生成される関数のところではGCが動く可能性があるので、オブジェクトがオブジェクトを保持している場合、ちゃんとマークされるかされないかを意識しないといけない。
もし、どこからもマークされない場合、一時的にスタックにオブジェクトをpushしないといけない。

new自体できないし継承してもnewができないクラス --> mCreateFun = NULLのクラス。

src/obj_void.c:    klass->mCreateFun = NULL;
src/obj_anonymous.c:    klass->mCreateFun = NULL;
src/obj_type_object.c:    klass->mCreateFun = NULL;
src/obj_block.c:    klass->mCreateFun = NULL;

以下はNEW_OBJECTの命令があるため、mCreateFun = NULLでも継承してnewできるし、継承してもOK
src/obj_user_object.c:    klass->mCreateFun = NULL;

引数の型は静的に決まる。デフォルト引数があるので、そうするしかなかった。

dynamic_typingをつけたクラスはmethod callがダックタイピング。
全ての型のオブジェクトを代入できるし、また全ての型に代入することができる。
voidを返すmethodは初期化されていないオブジェクトを返す。

-+- clover -+----------------------------------
try, catchの後スタックがおかしくなる。
catchがまだ未完成。
catchは例外の種類に応じて、いくつもつけることができるらしい。
例外の再チェック。まだ完成していない。
例外のメッセージをチェック。
vm.cのExceptionで型が単なるException型のものがあるが、あれでいいのか。

基本ライブラリを作っていく。

Fileクラスはユーザークラスにする。specialじゃなくても実装できる。

Array, List, Hashの実装。genericsのテスト。Array<Array<String>>など再起構造にも対応。

Hashがまだ全然コーディングできていない。
src/vm.cのNEW_HASHなど。



ブロックの戻り値はbreakで返した方が良くないか？
String str = String { int a = 0; a++; break "AAA" };
今だとString str = String { "AAA" };となっている

ヒープをページ単位に書き直す。ページのサイズを越えるときは単にCALLOCする。
今のままだだとヒープのoffsetが左辺値、reallocが起こり得る関数が右辺値にくる代入文がおかしくなる。

File, RegularFileの実装。file.clを通す

String.to_int(); String.to_float();

FieldInitializerのリファクタリング。もっと簡単にできる。

RegularFileクラス、Fileクラスの実装。

File.FileのモードにO_WRONLYなども指定できるように
File(String file_name, int mode);
のコンストラクタも作る。

pipeout, pipeinで外部プログラムと連携

文字列処理を入れる。
string_appendの実装。stringの仕様を変える。文字列を伸ばせるようにする。

mixinとsuperのgenerics対応とテスト。

Mutexのテスト

ユーザーのオリジナルスペシャルクラスを作る場合、native methodの登録をどうするか。動的ライブラリを使うか。

Clover.class_dependences(MyClass); 
クラスの依存クラスを文字列の配列で返す。クラスオブジェクトは無し。クラスは文字列で表す

Clover.class_file_path(MyClass); クラスファイルの絶対パスを返す

引数数-1の処理をちゃんとする。printfもできるようにちゃんとする。
Clover.printf

generics未実装なもの
    定数の引数
    methodスコープのgenerics
    generics型同士の代入。ワイルドカード<? super ClassA>など。

compiler.cでパースのエラー処理、expect系が不完全。少し予想外が起こるとエラー出力が滅茶苦茶になる。

privateクラスの実装、compiler.cはできている。namespace内でしか使えないクラス。

GCの改良。毎回コンパクションはしない
世代別GC

special classesもfieldの追加ができるようにする？できなくもない、、、。
Array, String, Hashもフィールドを追加できるようにする。Array, String, Hashの子クラスでフィールドを追加したい。
