
/// special classes ///
final class Field implements ICloneable, IInspectable 
{
    native void setValue(Field field);

    virtual Field clone() throws Exception {
        Field new_field = new Field();
        new_field.setValue(self);
        return new_field;
    }

    native bool isStaticField() throws NullPointerException;
    native bool isPrivateField() throws NullPointerException;
    native bool isProtectedField() throws NullPointerException;

    native String name() throws NullPointerException, ConvertingStringCodeException;

    native Type fieldType();

    bool isPublicField() throws NullPointerException {
        return !self.isPrivateField() && !self.isProtectedField();
    }

    virtual String toString() {
        return self.fieldType().toString() + " " + self.name();
    }
}

final class Method implements ICloneable, IInspectable 
{
    native void setValue(Method field);

    virtual Method clone() throws Exception {
        Method new_method = new Method();
        new_method.setValue(self);
        return new_method;
    }

    native bool isNativeMethod();
    native bool isClassMethod();
    native bool isPrivateMethod();
    native bool isConstructor();
    native bool isSynchronizedMethod();
    native bool isVirtualMethod();
    native bool isAbstractMethod();
    native bool isGenericsNewableConstructor();
    native bool isProtectedMethod();
    native bool isParamVariableArguments();

    bool isPublicMethod() {
        return !self.isPrivateMethod() && !self.isProtectedMethod();
    }

    native String name();
    native String path();

    native Type resultType();
    native Array<Type> parametors();
    native Type blockResultType();
    native Array<Type> blockParametors();
    native Array<Type> exceptions();

    virtual String toString() {
        return self.resultType().toString() + " " + self.name() + "(" + self.parametors().toString() + ") with " + self.blockResultType().toString() + "(" + self.blockParametors().toString() + ") throws " + self.exceptions().toString();
    }
}

final class Class implements ICloneable, IInspectable, IComparable
{
    native void setValue(Class class);

    virtual Class clone() throws Exception {
        Class new_class = new Class();
        new_class.setValue(self);
        return new_class;
    }

    String name() {
        return self.toString();
    }

    virtual native String toString();
    native anonymous newInstance();
    native bool isSpecialClass();
    native bool isInterface();
    native bool isAbstractClass();
    native bool isFinalClass();
    native bool isStruct();

    native Array<Field> fields();
    native Array<Method> methods();

    virtual bool operator ==(Class right) {
        return self.toString() == right.toString();
    }

    virtual bool operator !=(Class right) {
        return !(self == right);
    }

    native Array<Type> superClasses();
    native Array<Type> implementedInterfaces();
    native Array<Class> classDependences();
}

class Object implements IHashKey, IInspectable, IComparableMore, ICloneable
{
    native Type type() throws ConvertingStringCodeException;
    native int ID();
    native bool isUninitialized();
    native anonymous fields(int num) throws Exception, RangeException;
    native anonymous setField(int num, anonymous obj) throws Exception, RangeException;
    native int numFields();

    bool instanceOf(Type@Nullable type_object) {
        return self.type() == type_object;
    }
    bool isChild(Type@Nullable type_object) {
        Type it = self.type();
        while(it != null) {
            if(it == type_object) {
                return true;
            }
            it = it.parentClass();
        }

        return false;
    }

    Null toNull() throws TypeError {
        if(self.type() == Null) {
            return self;
        }
        else {
            throw new TypeError("type error");
        }
    }

    virtual int hashValue() {
        int sum = 0;
        for(int i=0; i<self.numFields(); i++) {
            sum += self.fields(i).ID();
        }
        return sum + self.ID();
    }

    virtual String toString() {
        return self.type().toString();
    }

    virtual bool operator ==(Object right) {
        /// null type ///
        if(self.type() == Null || right.type() == Null) {
            return self.type() == Null && right.type() == Null;
        }
        /// other type ///
        else {
            return self.ID() == right.ID();
        }
    }

    virtual bool operator !=(Object right) {
        return !(self == right);
    }

    virtual bool operator >(Object right) {
        return self.ID() > right.ID();
    }

    virtual bool operator <(Object right) {
        return self.ID() < right.ID();
    }

    virtual bool operator >=(Object right) {
        return self > right || self == right;
    }

    virtual bool operator <=(Object right) {
        return self < right || self == right;
    }

    virtual anonymous clone() throws Exception {
        /// special class object ///
        if(self.type().classObject().isSpecialClass()) {
            throw new Exception("An object of special class can't clone at Object.clone(). A special class should define clone method.");
        }
        /// user object ///
        else {
            Object new_object = self.type().classObject().newInstance();
            for(int i=0; i<self.numFields(); i++) {
                new_object.setField(i, self.fields(i).clone());
            }
            return new_object;
        }
    }
}

final class Type implements ICloneable, IInspectable, IComparable
{
    native void setValue(Type type);

    virtual native String toString();
    native bool equals(Type@Nullable value);
    native Class classObject();

    native Type class();
    native Type genericsParam(int index);
    native int genericsParamNumber();
    native Type@CheckForNull parentClass();
    native int parentClassNumber();

    virtual bool operator ==(Type@Nullable value) {
        return self.equals(value);
    }
    virtual bool operator !=(Type@Nullable value) {
        return !(self == value);
    }
    Type operator [](int index) {
        return self.genericsParam(index);
    }

    virtual Type clone() throws Exception {
        Type new_type = new Type();
        new_type.setValue(self);
        return new_type;
    }
}

dynamic_typing final abstract class anonymous 
{
}

final abstract class void
{
}

dynamic_typing final class Null implements ICloneable, IComparable, IInspectable, IComparable
{
    Null() {
    }

    int toInt() {
        return 0;
    }
    virtual String toString() {
        return "null";
    }
    bool toBool() {
        return false;
    }

    virtual bool operator ==(anonymous@Nullable value) {
        return self.type() == Null && value.type() == Null;
    }
    virtual bool operator !=(anonymous@Nullable value) {
        return !(self == value);
    }

    virtual Null clone() throws Exception {
        Null new_null = new Null();
        return new_null;
    }
}

struct int implements ICloneable, IComparableMore, IInspectable
{
    virtual native String toString();
    native byte toByte(); // throws OverflowException;
    native float toFloat(); 

    native int setValue(int value);
    native int getValue();

    native int upcase();            // 'a' --> 'A'
    native int downcase();          // 'A' --> 'a'

    virtual int hashValue() {
        return self;
    }

    virtual int clone() throws Exception{
        int new_object = new int();
        new_object.setValue(self);
        return new_object;
    }

    bool toBool() {
        return self != 0;
    }

    generics_newable int(int value) {
        self.setValue(value);
    }

    int operator ++() {
        self.setValue(self + 1);
        return self;
    }
    int operator ++2() {
        self.setValue(self + 1);
        return self -1;
    }
    int operator --() {
        self.setValue(self - 1);
        return self;
    }
    int operator --2() {
        self.setValue(self - 1);
        return self + 1;
    }
    int operator +=(int value) {
        return self \+= value;
    }
    int operator -=(int value) {
        return self \-= value;
    }
    int operator *=(int value) {
        return self \*= value;
    }
    int operator /=(int value) {
        return self \/= value;
    }
    int operator %=(int value) {
        return self \%= value;
    }
    int operator <<=(int value) {
        return self \<<= value;
    }
    int operator >>=(int value) {
        return self \>>= value;
    }
    int operator &=(int value) {
        return self \&= value;
    }
    int operator ^=(int value) {
        return self \^= value;
    }
    int operator |=(int value) {
        return self \|= value;
    }
    int operator +(int value) {
        return self \+ value;
    }
    int operator -(int value) {
        return self \- value;
    }
    int operator *(int value) {
        return self \* value;
    }
    int operator %(int value) {
        return self \% value;
    }
    int operator /(int value) {
        return self \/ value;
    }
    int operator <<(int value) {
        return self \<< value;
    }
    int operator >>(int value) {
        return self \>> value;
    }
    virtual bool operator ==(int@Nullable value) {
        return self \== value;
    }
    virtual bool operator !=(int@Nullable value) {
        return self \!= value;
    }
    virtual bool operator <(int value) {
        return self \< value;
    }
    virtual bool operator <=(int value) {
        return self \<= value;
    }
    virtual bool operator >(int value) {
        return self \> value;
    }
    virtual bool operator >=(int value) {
        return self \>= value;
    }
    int operator &(int value) {
        return self \& value;
    }
    int operator ^(int value) {
        return self \^ value;
    }
    int operator |(int value) {
        return self \| value;
    }
    int operator ~() {
        return \~self;
    }
}

struct float implements ICloneable, IInspectable, IComparableMore
{ 
    native int toInt();
    virtual native String toString();

    native float setValue(float value);
    native float getValue();

    generics_newable float(float value) {
        self.setValue(value);
    }

    virtual float clone() throws Exception{
        float new_object = new float();
        new_object.setValue(self);
        return new_object;
    }

    float operator ++() {
        self.setValue(self + 1.toFloat());
        return self;
    }
    float operator ++2() {
        self.setValue(self + 1.toFloat());
        return self -1.toFloat();
    }
    float operator --() {
        self.setValue(self - 1.toFloat());
        return self;
    }
    float operator --2() {
        self.setValue(self - 1.toFloat());
        return self + 1.toFloat();
    }
    float operator +=(float value) {
        return self \+= value;
    }
    float operator -=(float value) {
        return self \-= value;
    }
    float operator *=(float value) {
        return self \*= value;
    }
    float operator /=(float value) {
        return self \/= value;
    }
    float operator +(float value) {
        return self \+ value;
    }
    float operator -(float value) {
        return self \- value;
    }
    float operator *(float value) {
        return self \* value;
    }
    float operator /(float value) {
        return self \/ value;
    }
    virtual bool operator ==(float@Nullable value) {
        return self \== value;
    }
    virtual bool operator !=(float@Nullable value) {
        return self \!= value;
    }
    virtual bool operator <(float value) {
        return self \< value;
    }
    virtual bool operator <=(float value) {
        return self \<= value;
    }
    virtual bool operator >(float value) {
        return self \> value;
    }
    virtual bool operator >=(float value) {
        return self \>= value;
    }
}

struct byte implements IComparableMore, ICloneable, IInspectable {
    virtual native String toString();
    native int toInt();

    native byte downcase();
    native byte upcase();

    native byte setValue(byte value);
    native byte getValue();

    generics_newable byte(byte value) {
        self.setValue(value);
    }

    virtual byte clone() throws Exception{
        byte new_object = new byte();
        new_object.setValue(self);
        return new_object;
    }

    byte operator ++() {
        self.setValue(self + 1.toByte());
        return self;
    }
    byte operator ++2() {
        self.setValue(self + 1.toByte());
        return self - 1.toByte();
    }
    byte operator --() {
        self.setValue(self - 1.toByte());
        return self;
    }
    byte operator --2() {
        self.setValue(self - 1.toByte());
        return self + 1.toByte();
    }
    byte operator +=(byte value) {
        return self \+= value;
    }
    byte operator -=(byte value) {
        return self \-= value;
    }
    byte operator *=(byte value) {
        return self \*= value;
    }
    byte operator /=(byte value) {
        return self \/= value;
    }
    byte operator %=(byte value) {
        return self \%= value;
    }
    byte operator <<=(byte value) {
        return self \<<= value;
    }
    byte operator >>=(byte value) {
        return self \>>= value;
    }
    byte operator &=(byte value) {
        return self \&= value;
    }
    byte operator ^=(byte value) {
        return self \^= value;
    }
    byte operator |=(byte value) {
        return self \|= value;
    }
    byte operator +(byte value) {
        return self \+ value;
    }
    byte operator -(byte value) {
        return self \- value;
    }
    byte operator *(byte value) {
        return self \* value;
    }
    byte operator %(byte value) {
        return self \% value;
    }
    byte operator /(byte value) {
        return self \/ value;
    }
    byte operator <<(byte value) {
        return self \<< value;
    }
    byte operator >>(byte value) {
        return self \>> value;
    }
    virtual bool operator ==(byte@Nullable value) {
        return self \== value;
    }
    virtual bool operator !=(byte@Nullable value) {
        return self \!= value;
    }
    virtual bool operator <(byte value) {
        return self \< value;
    }
    virtual bool operator <=(byte value) {
        return self \<= value;
    }
    virtual bool operator >(byte value) {
        return self \> value;
    }
    virtual bool operator >=(byte value) {
        return self \>= value;
    }
    byte operator &(byte value) {
        return self \& value;
    }
    byte operator ^(byte value) {
        return self \^ value;
    }
    byte operator |(byte value) {
        return self \| value;
    }
    byte operator ~() {
        return \~self;
    }
}

struct bool implements IComparable, ICloneable, IInspectable  {
    native bool setValue(bool value);
    native bool getValue();

    generics_newable bool(bool value) {
        self.setValue(value);
    }

    virtual bool clone() throws Exception{
        bool new_object = new bool();
        new_object.setValue(self);
        return new_object;
    }

    virtual String toString() {
        if(self) {
            return "true";
        }
        else {
            return "false";
        }
    }
    int toInt() {
        if(self) {
            return 1;
        }
        else {
            return 0;
        }
    }
    
    bool operator !() {
        return \!self;
    }
    bool operator &&(bool value) {
        return self \&& value;
    }
    bool operator ||(bool value) {
        return self \|| value;
    }

    virtual bool operator ==(bool@Nullable value) {
        return self \== value;
    }
    virtual bool operator !=(bool@Nullable value) {
        return self \!= value;
    }
}

class Enum {
    //native static Hash<int> toHash();
}

/*
enum Encodings {
    Utf8, EucJP, SJIS
}
*/

class Encoding {
    int encode;

/*
    Encoding(int encode) throws Exception {
        if(Encodings.toHash().values().include(encode)) {
            self.encode = encode;
        }
        else {
            throw new Exception("Clover doesn't support this encoding");
        }
    }
*/
}

class Regex implements ICloneable, IInspectable {
    native String source();
    native bool ignoreCase();
    native bool multiLine();
    native Encoding encode();

    native void compile(String source, bool ignore_case, bool mutiline, Encoding encode) throws InvalidRegexException;

    generics_newable Regex(String source, bool ignore_case, bool multiline, Encoding encode) 
    {
        self.compile(source, ignore_case, multiline, encode);
    }

    virtual Regex clone() throws Exception{
        return new Regex(self.source(), self.ignoreCase(), self.multiLine(), self.encode());
    }

    virtual String toString() {
        return self.source();
    }
}

class String implements IComparableMore, ICloneable, IHashKey, IInspectable {
    native String setValue(String value);
    native String getValue();

    virtual String clone() throws Exception{
        String new_string = new String();
        new_string.setValue(self);
        return new_string;
    }

    virtual int hashValue() {
        int hash_value = 0;

        for(int i=0; i<self.length(); i++) {
            hash_value += self.char(i);
        }

        return hash_value;
    }

    native int length();

    native int char(int index) throws RangeException;

    native int replace(int index, int character) throws RangeException;

    native Bytes toBytes() throws ConvertingStringCodeException;

    native int cmp(String right);

    generics_newable String(String value) {
        self.setValue(value);
    }

    void print() {
        Clover.print(self);
    }
    void println() {
        Clover.println(self);
    }

    int operator[] (int index) throws RangeException {
        return self.char(index);
    }

    int operator[]= (int index, int character) throws RangeException {
        return self.replace(index, character);
    }

    String operator +(String value) {
        return self \+ value;
    }

    String operator+= (String string) {
        self.setValue(self + string);
        return self;
    }

    virtual bool operator==(String@Nullable right) {
        return (self \== right);
    }
    virtual bool operator!=(String@Nullable right) {
        return !(self \== right);
    }
    virtual bool operator>(String right) {
        return self.cmp(right) == 1;
    }

    virtual bool operator<(String right) {
        return self.cmp(right) == -1;
    }

    virtual bool operator>=(String right) {
        return self.cmp(right) == 1 || self \== right;
    }

    virtual bool operator<=(String right) {
        return self.cmp(right) == -1 || self \== right;
    }
    String operator *(int num) {
        String new_string = new String();
        for(int i=0; i<num; i++) {
            new_string += self;
        }
        return new_string;
    }

    virtual String toString() { return self; }

    String upcase() {
        String new_string = self.clone();
        for(int i=0; i<self.length(); i++) {
            new_string.replace(i, self.char(i).upcase());
        }

        return new_string;
    }

    String downcase() {
        String new_string = self.clone();
        for(int i=0; i<self.length(); i++) {
            new_string.replace(i, self.char(i).downcase());
        }

        return new_string;
    }
}

class Bytes implements IComparableMore, ICloneable, IInspectable {
    native Bytes setValue(Bytes value);
    native Bytes getValue();

    virtual Bytes clone() throws Exception{
        Bytes new_string = new Bytes();
        new_string.setValue(self);
        return new_string;
    }

    native int length();

    native byte char(int index) throws RangeException;
    native byte replace(int index, byte c);
    virtual native String toString();

    native int cmp(Bytes right);

    generics_newable Bytes(Bytes value) {
        self.setValue(value);
    }

    byte operator[] (int index) throws RangeException {
        return self.char(index);
    }
    byte operator[]= (int index, byte c) {
        return self.replace(index, c);
    }

    Bytes operator+= (Bytes string) {
        self.setValue(self + string);
        return self;
    }

    virtual bool operator==(Bytes@Nullable right) {
        return (self \== right);
    }
    virtual bool operator!=(Bytes@Nullable right) {
        return !(self \== right);
    }
    virtual bool operator>(Bytes right) {
        return self.cmp(right) == 1;
    }

    virtual bool operator<(Bytes right) {
        return self.cmp(right) == -1;
    }

    virtual bool operator>=(Bytes right) {
        return self.cmp(right) == 1 || self \== right;
    }

    virtual bool operator<=(Bytes right) {
        return self.cmp(right) == -1 || self \== right;
    }

    Bytes operator +(Bytes value) {
        return self \+ value;
    }

    Bytes upcase() {
        Bytes new_string = self.clone();
        for(int i=0; i<self.length(); i++) {
            new_string.replace(i, self.char(i).upcase());
        }

        return new_string;
    }

    Bytes downcase() {
        Bytes new_string = self.clone();
        for(int i=0; i<self.length(); i++) {
            new_string.replace(i, self.char(i).downcase());
        }

        return new_string;
    }
}

class Range implements ICloneable, IInspectable, IComparable {
    native void setHead(int head);
    native void setTail(int tail);
    native void setValue(Range range);
    native int head();
    native int tail();

    virtual Range clone() throws Exception{
        Range new_range = new Range();
        new_range.setHead(self.head());
        new_range.setTail(self.tail());
        return new_range;
    }

    virtual bool operator==(Range@Nullable range) {
        if(self.type() == Null || range.type() == Null) {
            return self.type() == Null && range.type() == Null;
        }

        return self.head() == range.head() && self.tail() == range.tail();
    }

    virtual bool operator!=(Range@Nullable range) {
        return !(self == range);
    }

    bool include(int number) {
        return number >= self.head() && number <= self.tail();
    }

    virtual String toString() {
        return self.head().toString() + ".." + self.tail().toString();
    }
}

class Array<T> implements ICloneable, IInspectable, IComparableMore
{
    native Array<T> setValue(Array<T> value);
    native Array<T> getValue();

    native void add(T@Nullable item);
    native T items(int index) throws RangeException;
    native int length();
    native T setItem(int index, T@Nullable item) throws RangeException;

    virtual Array<T> clone() throws Exception {
        Array<T> new_array = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            new_array.add(self.items(i).clone());
        }

        return new_array;
    }

    T items(int index, T@Nullable default) {
        int index2 = index;

        if(index2 < 0) {
            index2 += self.length();
        }

        if(index2 < 0 || index2 >= self.length()) {
            return default;
        }

        return self.items(index);
    }

    T items(int index) with T block(int index) {
        int index2 = index;

        if(index2 < 0) {
            index2 += self.length();
        }

        if(index2 < 0 || index2 >= self.length()) {
            return block(index2);
        }
    
        return self.items(index);
    }

    T find(int find_count=1) with bool block(T item) {
        int count = 0;
        for(int i=0; i<self.length(); i++) {
            if(block(self.items(i))) {
                count++;
                if(count == find_count) {
                    return self.items(i);
                }
            }
        }

        return null;
    }

    Array<T> operator*(int num) {
        Array<T> new_array = new Array<T>();

        for(int i=0; i<num; i++) {
            for(int j=0; j<self.length(); j++) {
                new_array.add(self.items(j));
            }
        }

        return new_array;
    }

    Array<T> operator + (Array<T> right) {
        Array<T> new_array = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        for(int i=0; i<right.length(); i++) {
            new_array.add(right.items(i));
        }

        return new_array;
    }

    virtual bool operator==(Array<T>@Nullable array2) {
        if(self.type() == Null || array2.type() == Null) {
            return self.type() == Null && array2.type() == Null;
        }

        if(self.length() != array2.length()) {
            return false;
        }

        for(int i=0; i<self.length(); i++) {
            if(self[i] != array2[i]) {
                return false;
            }
        }

        return true;
    }
    virtual bool operator!=(Array<T>@Nullable array2) {
        return !(self == array2);
    }

    virtual bool operator>(Array<T> right){
        if(self.type() == Null || right.type() == Null) {
            if(right.type() == Null) {
                return true;
            }
            else {
                return false;
            }
        }

        if(self.length() == 0 || right.length() == 0) {
            if(right.length() == 0) {
                return true;
            }
            else {
                return false;
            }
        }

        if(self.length() > right.length()) {
            return true;
        }
        else if(self.length() < right.length()) {
            return false;
        }

        if(self[0] > right[0]) {
            return true;
        }
        else {
            return false;
        }
    }

    virtual bool operator<(Array<T> right) {
        if(self.type() == Null || right.type() == Null) {
            if(right.type() == Null) {
                return false;
            }
            else {
                return true;
            }
        }

        if(self.length() == 0 || right.length() == 0) {
            if(right.length() == 0) {
                return false;
            }
            else {
                return true;
            }
        }

        if(self.length() > right.length()) {
            return false;
        }
        else if(self.length() < right.length()) {
            return true;
        }

        if(self[0] < right[0]) {
            return true;
        }
        else {
            return false;
        }
    }

    virtual bool operator>=(Array<T> right) {
        return self > right || self == right;
    }

    virtual bool operator<=(Array<T> right) {
        return self < right || self == right;
    }

    T operator[] (int index) throws RangeException {
        return self.items(index);
    }

    T operator[]= (int index, T item) throws RangeException {
        return self.setItem(index, item);
    }

    bool empty() {
        return self.length() == 0;
    }

    Array<T> compact() {
        Array<T> new_array = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            if(self.items(i) != null) {
                new_array.add(self.items(i));
            }
        }

        self.setValue(new_array);

        return self;
    }

    T deleteAt(int number) {
        T result = null;
        Array<T> new_array = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            if(i == number) {
                result = self.items(i);
            }
            else {
                new_array.add(self.items(i));
            }
        }

        self.setValue(new_array);

        return result;
    }

    T first() {
        return self.items(0);
    }

    T last() {
        return self.items(self.length()-1);
    }

    T pop() {
        if(self.length() == 0) {
            return null;
        }

        Array<T> new_array = new Array<T>();
        T result = self.items(self.length()-1);

        for(int i=0; i<self.length()-1; i++) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return result;
    }
    Array(Array<T> array) {
        self.setValue(array);
    }

    bool include(T item) {
        for(int i=0; i<self.length(); i++) {
            if(self.items(i) == item) {
                return true;
            }
        }

        return false;
    }

    int count(T item) {
        int c = 0;

        for(int i=0; i<self.length(); i++) {
            if(self.items(i) == item) {
                c++;
            }
        }

        return c;
    }

    T delete(T@Nullable item) {
        T result = null;

        Array<T> new_array = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            if(self.items(i) != item) {
                new_array.add(self.items(i));
            }
            else {
                result = self.items(i);
            }
        }

        self.setValue(new_array);

        return result;
    }

    int findIndex(T@Nullable item, int count=1) {
        int c = 0;

        for(int i=0; i<self.length(); i++) {
            if(self.items(i) == item) {
                c++;

                if(c == count) {
                    return i;
                }
            }
        }

        return -1;
    }

    int findIndex(int count=1) with bool block(T item) {
        int c = 0;

        for(int i=0; i<self.length(); i++) {
            if(block(self.items(i))) {
                c++;

                if(c == count) {
                    return i;
                }
            }
        }

        return -1;
    }

    virtual String toString() {
        String result = "{";

        for(int i=0; i<self.length(); i++) {
            if(i == self.length()-1) {
                result += self.items(i).toString();
            }
            else {
                result += self.items(i).toString();
                result += ",";
            }
        }

        result += "}";

        return result;
    }

    String join(String separator="") {
        String result = "";

        for(int i=0; i<self.length(); i++) {
            if(i == self.length()-1) {
                result += self.items(i).toString();
            }
            else {
                result += self.items(i).toString();
                result += separator;
            }
        }

        return result;
    }

    int rindex(T@Nullable item, int count=1) {
        int c = 0;
        for(int i=self.length()-1; i>=0; i--) {
            if(self.items(i) == item) {
                c++;

                if(c == count) {
                    return i;
                }
            }
        }

        return -1;
    }

    int rindex(int count=1) with bool block(T item) {
        int c = 0;
        for(int i=self.length()-1; i>=0; i--) {
            if(block(self.items(i))) {
                c++;

                if(c == count) {
                    return i;
                }
            }
        }

        return -1;
    }

    Array<T> each() with void block(T item) {
        for(int i=0; i<self.length(); i++) {
            block(self.items(i));
        }

        return self;
    }
    Array<T> each() with void block(T item, int index) {
        for(int i=0; i<self.length(); i++) {
            block(self.items(i), i);
        }

        return self;
    }
    Array<T> clear() {
        self.setValue(new Array<T>());
        return self;
    }

    Array<anonymous> collect() with anonymous block(T item) {
        Array<anonymous> new_array = new Array<anonymous>();

        for(int i=0; i<self.length(); i++) {
            new_array.add(block(self.items(i)));
        }

        return new_array;
    }

    Array<T> concat(Array<T> array) {
        for(int i=0; i<array.length(); i++) {
            self.add(array.items(i));
        }

        return self;
    }

    Array<T> cycle(int number) with void block(T item) {
        for(int i=0; i<number; i++) {
            for(int j=0; j<self.length(); j++) {
                block(self.items(j));
            }
        }

        return self;
    }

    Array<T> deleteIf() with bool block(T item) {
        Array<T> new_array = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            if(!block(self.items(i))) {
                new_array.add(self.items(i));
            }
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> drop(int number) {
        Array<T> new_array = new Array<T>();

        for(int i=number; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> dropWhile() with bool block(T item) {
        Array<T> new_array = new Array<T>();
        bool addition = false;

        for(int i=0; i<self.length(); i++) {
            if(!addition && !block(self.items(i))) {
                addition = true;
            }

            if(addition) {
                new_array.add(self.items(i));
            }
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> eachIndex() with void block(int index) {
        for(int i=0; i<self.length(); i++) {
            block(i);
        }

        return self;
    }

    Array<T> fill(T@Nullable item) {
        for(int i=0; i<self.length(); i++) {
            self.setItem(i, item);
        }

        return self;
    }

    Array<T> fill() with T block(int index) {
        for(int i=0; i<self.length(); i++) {
            self.setItem(i, block(i));
        }

        return self;
    }

    Array<T> fill(T@Nullable item, Range range) throws RangeException{
        int head = range.head();
        int tail = range.tail();

        if(head < 0) {
            head += self.length();
        }

        if(tail < 0) {
            tail += self.length();
        }

        if(head < 0 || head >= self.length()) {
            throw new RangeException("Range Exception");
        }

        if(tail < 0 || tail >= self.length()) {
            throw new RangeException("Range Exception");
        }

        for(int i=head; i<=tail; i++) {
            self.setItem(i, item);
        }

        return self;
    }

    Array<T> fill(Range range) with T block(int index) throws RangeException{
        int head = range.head();
        int tail = range.tail();

        if(head < 0) {
            head += self.length();
        }

        if(tail < 0) {
            tail += self.length();
        }

        if(head < 0 || head >= self.length()) {
            throw new RangeException("Range Exception");
        }

        if(tail < 0 || tail >= self.length()) {
            throw new RangeException("Range Exception");
        }

        for(int i=head; i<=tail; i++) {
            self.setItem(i, block(i));
        }

        return self;
    }

    Array<T> first(int num) throws RangeException {
        Array<T> new_array = new Array<T>();

        if(num < 0 || num >= self.length()) {
            throw new RangeException("Range Exception");
        }

        for(int i=0; i<num; i++) {
            new_array.add(self.items(i));
        }

        return new_array;
    }

    Array<T> insert(int index, T@Nullable item) throws RangeException {
        Array<T> new_array = new Array<T>();

        if(index < 0) {
            index += self.length();
        }

        if(index < 0 || index >= self.length()) {
            throw new RangeException("RangeException");
        }

        for(int i=0; i<index; i++) {
            new_array.add(self.items(i));
        }

        new_array.add(item);

        for(int i=index; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> insert(int index, Array<T> array) throws RangeException {
        Array<T> new_array = new Array<T>();

        if(index < 0) {
            index += self.length();
        }

        if(index < 0 || index >= self.length()) {
            throw new RangeException("RangeException");
        }

        for(int i=0; i<index; i++) {
            new_array.add(self.items(i));
        }

        for(int i=0; i<array.length(); i++) {
            new_array.add(array.items(i));
        }

        for(int i=index; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> keepIf() with bool block(T item) {
        Array<T> new_array = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            if(block(self.items(i))) {
                new_array.add(self.items(i));
            }
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> last(int num) {
        Array<T> new_array = new Array<T>();

        for(int i=self.length()-num; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        return new_array;
    }
    Array<T> pop(int num) {
        if(self.length() == 0) {
            return null;
        }

        Array<T> new_array = new Array<T>();
        Array<T> new_array2 = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            if(i < self.length()-num) {
                new_array.add(self.items(i));
            }
            else {
                new_array2.add(self.items(i));
            }
        }

        self.setValue(new_array);

        return new_array2;
    }

    Array<T> push(T@Nullable item) {
        self.add(item);
        return self;
    }

    Array<T> reverse() {
        Array<T> new_array = new Array<T>();

        for(int i=self.length()-1; i>=0; i--) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> rotate(int num) throws RangeException {
        Array<T> new_array = new Array<T>();

        if(num < 0) {
            for(int i=self.length()+num; i<self.length(); i++) {
                new_array.add(self.items(i));
            }
            for(int i=0; i<self.length()+num; i++) {
                new_array.add(self.items(i));
            }
        }
        else if(num == 0) {
            new_array.setValue(self);
        }
        else {
            for(int i=num; i<self.length(); i++) {
                new_array.add(self.items(i));
            }
            for(int i=0; i<num; i++) {
                new_array.add(self.items(i));
            }
        }

        self.setValue(new_array);

        return self;
    }

    T sample() {
        int index = System.rand() % self.length();

        return self.items(index);
    }

    Array<T> sample(int num) {
        Array<T> new_array = new Array<T>();

        for(int i=0; i<num; i++) {
            int index = System.rand() % self.length();

            new_array.add(self.items(index));
        }

        return new_array;
    }

    T shift() {
        Array<T> new_array = new Array<T>();

        T result = self.items(0);

        for(int i=1; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return result;
    }

    Array<T> shift(int num) {
        Array<T> new_array = new Array<T>();

        Array<T> result = new Array<T>();

        for(int i=0; i<num; i++) {
            result.add(self.items(i));
        }

        for(int i=num; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return result;
    }

    Array<T> unshift(T@Nullable item) {
        Array<T> new_array = new Array<T>();

        new_array.add(item);

        for(int i=0; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> unshift(Array<T> array) {
        Array<T> new_array = new Array<T>();

        for(int i=0; i<array.length(); i++) {
            new_array.add(array.items(i));
        }

        for(int i=0; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> shuffle() {
        Array<T> new_array = new Array<T>();

        Array<int> squence = new Array<int>();

        for(int i=0; i<self.length(); i++) {
            squence.add(i);
        }

        for(int i=0; i<self.length() * 2; i++) {
            int num = System.rand() % self.length();
            int num2 = System.rand() % self.length();

            if(num != num2) {
                int temp = squence[num];
                squence[num] = squence[num2];
                squence[num2] = temp;
            }
        }

        for(int i=0; i<self.length(); i++) {
            new_array.add(self.items(squence[i]));
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> slice(Range range) throws RangeException {
        Array<T> result = new Array<T>();

        for(int i=range.head(); i<=range.tail(); i++) {
            result.add(self.items(i));
        }

        return result;
    }

    Array<T> operator[](Range range) throws RangeException {
        return self.slice(range);
    }

    Array<T> take(int num) {
        Array<T> result = new Array<T>();

        for(int i=0; i<num; i++) {
            result.add(self.items(i));
        }

        return result;
    }

    Array<T> takeWhile() with bool block(T item) {
        Array<T> new_array = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            if(!block(self.items(i))) {
                break;
            }

            new_array.add(self.items(i));
        }

        return new_array;
    }

    Array<T> toArray() {
        return self;
    }

    Array<T> uniq() {
        Array<T> new_array = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            if(!new_array.include(self.items(i))) {
                new_array.add(self.items(i));
            }
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> uniq() with T block(T item) {
        Array<T> new_array = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            T item2 = block(self.items(i));

            bool found = false;
            for(int j=0; j<new_array.length(); j++) {
                T item3 = block(new_array.items(j));

                if(item3 == item2) {
                    found = true;
                    break;
                }
            }

            if(!found) {
                new_array.add(self.items(i));
            }
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> valueAt(Array<anonymous> params, ...) throws TypeError {
        Array<T> new_array = new Array<T>();

        params.each() {|anonymous param|
            if(param.type() == int) {
                int index = param;
                new_array.add(self.items(index));
            }
            else if(param.type() == Range) {
                Range range = param;
                for(int i=range.head(); i<=range.tail(); i++) {
                    new_array.add(self.items(i));
                }
            }
            else {
                throw new TypeError("Array.valueAt() requires Range or int parametor");
            }
        }

        return new_array;
    }

    private void quickSort(Array<T> array, int left, int right) {
        int l_hold = left;
        int r_hold = right;

        T pivot = array[left];
        int pivot_num = left;

        while(left < right) {
            while((array[right] >= pivot) && (left < right)) {
                right--;
            }

            if(left != right) {
                array[left] = array[right];
                left++;
            }

            while((array[left] <= pivot) && (left < right)) {
                left++;
            }

            if(left != right) {
                array[right] = array[left];
                right--;
            }
        }

        array[left] = pivot;

        pivot_num = left;

        left = l_hold;
        right = r_hold;
        if(left < pivot_num) {
            self.quickSort(array, left, pivot_num-1);
        }

        if(right > pivot_num) {
            self.quickSort(array, pivot_num+1, right);

        }
    }

    Array<T> sort() {
        Array<T> array = self.clone();
        
        array.quickSort(array, 0, self.length()-1);

        self.setValue(array);

        return self;
    }

    private void quickSortWithBlock(Array<T> array, int left, int right) with int block(T item, T item2) 
    {
        int l_hold = left;
        int r_hold = right;

        T pivot = array[left];
        int pivot_num = left;

        while(left < right) {
            while(bool { int result = block(array[right], pivot); result == 1 || result == 0} && (left < right)) {
                right--;
            }

            if(left != right) {
                array[left] = array[right];
                left++;
            }

            while(bool { int result2 = block(pivot, array[left]); result2 == 1 || result2 == 0} && (left < right)) 
            {
                left++;
            }

            if(left != right) {
                array[right] = array[left];
                right--;
            }
        }

        array[left] = pivot;

        pivot_num = left;

        left = l_hold;
        right = r_hold;
        if(left < pivot_num) {
            self.quickSortWithBlock(array, left, pivot_num-1) with block;
        }

        if(right > pivot_num) {
            self.quickSortWithBlock(array, pivot_num+1, right) with block;
        }
    }

    Array<T> sort() with int block(T item, T item2) {
        Array<T> array = self.clone();
        
        array.quickSortWithBlock(array, 0, self.length()-1) with block;

        self.setValue(array);

        return self;
    }

    private void quickSortBy(Array<T> array, int left, int right) with anonymous block(T item) {
        int l_hold = left;
        int r_hold = right;

        T pivot_item = array[left];
        anonymous pivot_value = block(array[left]);
        int pivot_num = left;

        while(left < right) {
            while((block(array[right]) >= pivot_value) && (left < right)) {
                right--;
            }

            if(left != right) {
                array[left] = array[right];
                left++;
            }

            while((block(array[left]) <= pivot_value) && (left < right)) {
                left++;
            }

            if(left != right) {
                array[right] = array[left];
                right--;
            }
        }

        array[left] = pivot_item;

        pivot_num = left;

        left = l_hold;
        right = r_hold;
        if(left < pivot_num) {
            self.quickSortBy(array, left, pivot_num-1) with block;
        }

        if(right > pivot_num) {
            self.quickSortBy(array, pivot_num+1, right) with block;

        }
    }

    Array<T> sortBy() with anonymous block(T item) {
        Array<T> array = self.clone();

        array.quickSortBy(array, 0, self.length()-1) with block;

        self.setValue(array);

        return array;

    }
}

class Tuple<T1> implements IHashKey, IInspectable, ICloneable, IComparableMore
{
    T1 value1;

    void set1(T1 value) {
        self.value1 = value;
    }

    T1 get1() {
        return self.value1;
    }

    virtual bool operator==(Tuple<T1> right) {
        return self.value1 == right.value1;
    }
    virtual bool operator!=(Tuple<T1> right) {
        return !(self == right);
    }

    virtual bool operator>(Tuple<T1> right) {
        return self.value1 > right.value1;
    }
    virtual bool operator<(Tuple<T1> right) {
        return self.value1 < right.value1;
    }
    virtual bool operator>=(Tuple<T1> right) {
        return self > right || self == right;
    }
    virtual bool operator<=(Tuple<T1> right) {
        return self < right || self == right;
    }

    virtual Tuple<T1> clone() throws Exception{
        Tuple<T1> new_tuple = new Tuple<T1>();

        new_tuple.set1(self.get1().clone());

        return new_tuple;
    }

    virtual String toString() {
        return "{" + self.value1.toString() + "}";
    }
    virtual int hashValue() {
        return self.value1.hashValue();
    }
}

class Tuple<T1, T2> implements IHashKey, IInspectable, ICloneable, IComparableMore
{
    T1 value1;
    T2 value2;

    void set1(T1 value) {
        self.value1 = value;
    }

    void set2(T2 value) {
        self.value2 = value;
    }

    T1 get1() {
        return self.value1;
    }

    T2 get2() {
        return self.value2;
    }

    virtual bool operator==(Tuple<T1, T2> right) {
        return self.value1 == right.value1 && self.value2 == right.value2;
    }
    virtual bool operator!=(Tuple<T1, T2> right) {
        return !(self == right);
    }

    virtual bool operator>(Tuple<T1, T2> right) {
        return self.value1 > right.value1;
    }
    virtual bool operator<(Tuple<T1, T2> right) {
        return self.value1 < right.value1;
    }
    virtual bool operator>=(Tuple<T1, T2> right) {
        return self > right || self == right;
    }
    virtual bool operator<=(Tuple<T1, T2> right) {
        return self < right || self == right;
    }

    virtual Tuple<T1, T2> clone() throws Exception{
        Tuple<T1, T2> new_tuple = new Tuple<T1, T2>();

        new_tuple.set1(self.get1().clone());
        new_tuple.set2(self.get2().clone());

        return new_tuple;
    }

    virtual String toString() {
        return "{" + self.value1.toString() + ":" + self.value2.toString() + "}";
    }
    virtual int hashValue() {
        return self.value1.hashValue() ^ self.value2.hashValue();
    }
}

class Tuple<T1, T2, T3> implements IHashKey, IInspectable, ICloneable, IComparableMore
{
    T1 value1;
    T2 value2;
    T3 value3;

    void set1(T1 value) {
        self.value1 = value;
    }

    void set2(T2 value) {
        self.value2 = value;
    }

    void set3(T3 value) {
        self.value3 = value;
    }

    T1 get1() {
        return self.value1;
    }

    T2 get2() {
        return self.value2;
    }

    T3 get3() {
        return self.value3;
    }

    virtual bool operator==(Tuple<T1, T2, T3> right) {
        return self.value1 == right.value1 && self.value2 == right.value2 && self.value3 == right.value3;
    }
    virtual bool operator!=(Tuple<T1, T2, T3> right) {
        return !(self == right);
    }

    virtual bool operator>(Tuple<T1, T2, T3> right) {
        return self.value1 > right.value1;
    }
    virtual bool operator<(Tuple<T1, T2, T3> right) {
        return self.value1 < right.value1;
    }
    virtual bool operator>=(Tuple<T1, T2, T3> right) {
        return self > right || self == right;
    }
    virtual bool operator<=(Tuple<T1, T2, T3> right) {
        return self < right || self == right;
    }

    virtual Tuple<T1, T2, T3> clone() throws Exception{
        Tuple<T1, T2, T3> new_tuple = new Tuple<T1, T2, T3>();

        new_tuple.set1(self.get1().clone());
        new_tuple.set2(self.get2().clone());
        new_tuple.set3(self.get3().clone());

        return new_tuple;
    }

    virtual String toString() {
        return "{" + self.value1.toString() + ":" + self.value2.toString() + ":" + self.value3.toString() + "}";
    }
    virtual int hashValue() {
        return self.value1.hashValue() ^ self.value2.hashValue() ^ self.value3.hashValue();
    }
}

class Tuple<T1, T2, T3, T4>  implements IHashKey, IInspectable, ICloneable, IComparableMore
{
    T1 value1;
    T2 value2;
    T3 value3;
    T4 value4;

    void set1(T1 value) {
        self.value1 = value;
    }

    void set2(T2 value) {
        self.value2 = value;
    }

    void set3(T3 value) {
        self.value3 = value;
    }

    void set4(T4 value) {
        self.value4 = value;
    }

    T1 get1() {
        return self.value1;
    }

    T2 get2() {
        return self.value2;
    }

    T3 get3() {
        return self.value3;
    }

    T4 get4() {
        return self.value4;
    }

    virtual bool operator==(Tuple<T1, T2, T3, T4> right) {
        return self.value1 == right.value1 && self.value2 == right.value2 && self.value3 == right.value3 && self.value4 == right.value4;
    }
    virtual bool operator!=(Tuple<T1, T2, T3, T4> right) {
        return !(self == right);
    }

    virtual bool operator>(Tuple<T1, T2, T3, T4> right) {
        return self.value1 > right.value1;
    }
    virtual bool operator<(Tuple<T1, T2, T3, T4> right) {
        return self.value1 < right.value1;
    }
    virtual bool operator>=(Tuple<T1, T2, T3, T4> right) {
        return self > right || self == right;
    }
    virtual bool operator<=(Tuple<T1, T2, T3, T4> right) {
        return self < right || self == right;
    }

    virtual Tuple<T1, T2, T3, T4> clone() throws Exception{
        Tuple<T1, T2, T3, T4> new_tuple = new Tuple<T1, T2, T3, T4>();

        new_tuple.set1(self.get1().clone());
        new_tuple.set2(self.get2().clone());
        new_tuple.set3(self.get3().clone());
        new_tuple.set4(self.get4().clone());

        return new_tuple;
    }

    virtual String toString() {
        return "{" + self.value1.toString() + ":" + self.value2.toString() + ":" + self.value3.toString() + ":" + self.value4.toString() + "}";
    }
    virtual int hashValue() {
        return self.value1.hashValue() ^ self.value2.hashValue() ^ self.value3.hashValue() ^ self.value4.hashValue();
    }
}

class Tuple<T1, T2, T3, T4, T5> implements IHashKey, IInspectable, ICloneable, IComparableMore
{
    T1 value1;
    T2 value2;
    T3 value3;
    T4 value4;
    T5 value5;

    void set1(T1 value) {
        self.value1 = value;
    }

    void set2(T2 value) {
        self.value2 = value;
    }

    void set3(T3 value) {
        self.value3 = value;
    }

    void set4(T4 value) {
        self.value4 = value;
    }

    void set5(T5 value) {
        self.value5 = value;
    }

    T1 get1() {
        return self.value1;
    }

    T2 get2() {
        return self.value2;
    }

    T3 get3() {
        return self.value3;
    }

    T4 get4() {
        return self.value4;
    }

    T5 get5() {
        return self.value5;
    }

    virtual bool operator==(Tuple<T1, T2, T3, T4, T5> right) {
        return self.value1 == right.value1 && self.value2 == right.value2 && self.value3 == right.value3 && self.value4 == right.value4 && self.value5 == right.value5;
    }
    virtual bool operator!=(Tuple<T1, T2, T3, T4, T5> right) {
        return !(self == right);
    }

    virtual bool operator>(Tuple<T1, T2, T3, T4, T5> right) {
        return self.value1 > right.value1;
    }
    virtual bool operator<(Tuple<T1, T2, T3, T4, T5> right) {
        return self.value1 < right.value1;
    }
    virtual bool operator>=(Tuple<T1, T2, T3, T4, T5> right) {
        return self > right || self == right;
    }
    virtual bool operator<=(Tuple<T1, T2, T3, T4, T5> right) {
        return self < right || self == right;
    }

    virtual Tuple<T1, T2, T3, T4, T5> clone() throws Exception{
        Tuple<T1, T2, T3, T4, T5> new_tuple = new Tuple<T1, T2, T3, T4, T5>();

        new_tuple.set1(self.get1().clone());
        new_tuple.set2(self.get2().clone());
        new_tuple.set3(self.get3().clone());
        new_tuple.set4(self.get4().clone());
        new_tuple.set5(self.get5().clone());

        return new_tuple;
    }

    virtual String toString() {
        return "{" + self.value1.toString() + ":" + self.value2.toString() + ":" + self.value3.toString() + ":" + self.value4.toString() + ":" + self.value5.toString() + "}";
    }
    virtual int hashValue() {
        return self.value1.hashValue() ^ self.value2.hashValue() ^ self.value3.hashValue() ^ self.value4.hashValue() ^ self.value5.hashValue();
    }
}

class Tuple<T1, T2, T3, T4, T5, T6>  implements IHashKey, IInspectable, ICloneable, IComparableMore
{
    T1 value1;
    T2 value2;
    T3 value3;
    T4 value4;
    T5 value5;
    T6 value6;

    void set1(T1 value) {
        self.value1 = value;
    }

    void set2(T2 value) {
        self.value2 = value;
    }

    void set3(T3 value) {
        self.value3 = value;
    }

    void set4(T4 value) {
        self.value4 = value;
    }

    void set5(T5 value) {
        self.value5 = value;
    }

    void set6(T6 value) {
        self.value6 = value;
    }

    T1 get1() {
        return self.value1;
    }

    T2 get2() {
        return self.value2;
    }

    T3 get3() {
        return self.value3;
    }

    T4 get4() {
        return self.value4;
    }

    T5 get5() {
        return self.value5;
    }

    T6 get6() {
        return self.value6;
    }

    virtual bool operator==(Tuple<T1, T2, T3, T4, T5, T6> right) {
        return self.value1 == right.value1 && self.value2 == right.value2 && self.value3 == right.value3 && self.value4 == right.value4 && self.value5 == right.value5 && self.value6 == right.value6;
    }
    virtual bool operator!=(Tuple<T1, T2, T3, T4, T5, T6> right) {
        return !(self == right);
    }

    virtual bool operator>(Tuple<T1, T2, T3, T4, T5, T6> right) {
        return self.value1 > right.value1;
    }
    virtual bool operator<(Tuple<T1, T2, T3, T4, T5, T6> right) {
        return self.value1 < right.value1;
    }
    virtual bool operator>=(Tuple<T1, T2, T3, T4, T5, T6> right) {
        return self > right || self == right;
    }
    virtual bool operator<=(Tuple<T1, T2, T3, T4, T5, T6> right) {
        return self < right || self == right;
    }

    virtual Tuple<T1, T2, T3, T4, T5, T6> clone() throws Exception{
        Tuple<T1, T2, T3, T4, T5, T6> new_tuple = new Tuple<T1, T2, T3, T4, T5, T6>();

        new_tuple.set1(self.get1().clone());
        new_tuple.set2(self.get2().clone());
        new_tuple.set3(self.get3().clone());
        new_tuple.set4(self.get4().clone());
        new_tuple.set5(self.get5().clone());
        new_tuple.set6(self.get6().clone());

        return new_tuple;
    }

    virtual String toString() {
        return "{" + self.value1.toString() + ":" + self.value2.toString() + ":" + self.value3.toString() + ":" + self.value4.toString() + ":" + self.value5.toString() + ":" + self.value6.toString() + "}";
    }
    virtual int hashValue() {
        return self.value1.hashValue() ^ self.value2.hashValue() ^ self.value3.hashValue() ^ self.value4.hashValue() ^ self.value5.hashValue() ^ self.value6.hashValue();
    }
}

class Tuple<T1, T2, T3, T4, T5, T6, T7>  implements IHashKey, IInspectable, ICloneable, IComparableMore
{
    T1 value1;
    T2 value2;
    T3 value3;
    T4 value4;
    T5 value5;
    T6 value6;
    T7 value7;

    void set1(T1 value) {
        self.value1 = value;
    }

    void set2(T2 value) {
        self.value2 = value;
    }

    void set3(T3 value) {
        self.value3 = value;
    }

    void set4(T4 value) {
        self.value4 = value;
    }

    void set5(T5 value) {
        self.value5 = value;
    }

    void set6(T6 value) {
        self.value6 = value;
    }

    void set7(T7 value) {
        self.value7 = value;
    }

    T1 get1() {
        return self.value1;
    }

    T2 get2() {
        return self.value2;
    }

    T3 get3() {
        return self.value3;
    }

    T4 get4() {
        return self.value4;
    }

    T5 get5() {
        return self.value5;
    }

    T6 get6() {
        return self.value6;
    }

    T7 get7() {
        return self.value7;
    }

    virtual bool operator==(Tuple<T1, T2, T3, T4, T5, T6, T7> right) {
        return self.value1 == right.value1 && self.value2 == right.value2 && self.value3 == right.value3 && self.value4 == right.value4 && self.value5 == right.value5 && self.value6 == right.value6 && self.value7 == right.value7;
    }
    virtual bool operator!=(Tuple<T1, T2, T3, T4, T5, T6, T7> right) {
        return !(self == right);
    }

    virtual bool operator>(Tuple<T1, T2, T3, T4, T5, T6, T7> right) {
        return self.value1 > right.value1;
    }
    virtual bool operator<(Tuple<T1, T2, T3, T4, T5, T6, T7> right) {
        return self.value1 < right.value1;
    }
    virtual bool operator>=(Tuple<T1, T2, T3, T4, T5, T6, T7> right) {
        return self > right || self == right;
    }
    virtual bool operator<=(Tuple<T1, T2, T3, T4, T5, T6, T7> right) {
        return self < right || self == right;
    }

    virtual Tuple<T1, T2, T3, T4, T5, T6, T7> clone() throws Exception{
        Tuple<T1, T2, T3, T4, T5, T6, T7> new_tuple = new Tuple<T1, T2, T3, T4, T5, T6, T7>();

        new_tuple.set1(self.get1().clone());
        new_tuple.set2(self.get2().clone());
        new_tuple.set3(self.get3().clone());
        new_tuple.set4(self.get4().clone());
        new_tuple.set5(self.get5().clone());
        new_tuple.set6(self.get6().clone());
        new_tuple.set7(self.get7().clone());

        return new_tuple;
    }

    virtual String toString() {
        return "{" + self.value1.toString() + ":" + self.value2.toString() + ":" + self.value3.toString() + ":" + self.value4.toString() + ":" + self.value5.toString() + ":" + self.value6.toString() + ":" + self.value7.toString() + "}";
    }
    virtual int hashValue() {
        return self.value1.hashValue() ^ self.value2.hashValue() ^ self.value3.hashValue() ^ self.value4.hashValue() ^ self.value5.hashValue() ^ self.value6.hashValue() ^ self.value7.hashValue();
    }
}

class Tuple<T1, T2, T3, T4, T5, T6, T7, TRest>  implements IHashKey, IInspectable, ICloneable, IComparableMore
{
    T1 value1;
    T2 value2;
    T3 value3;
    T4 value4;
    T5 value5;
    T6 value6;
    T7 value7;
    TRest rest;

    void set1(T1 value) {
        self.value1 = value;
    }

    void set2(T2 value) {
        self.value2 = value;
    }

    void set3(T3 value) {
        self.value3 = value;
    }

    void set4(T4 value) {
        self.value4 = value;
    }

    void set5(T5 value) {
        self.value5 = value;
    }

    void set6(T6 value) {
        self.value6 = value;
    }

    void set7(T7 value) {
        self.value7 = value;
    }

    void setRest(TRest value) {
        self.rest = value;
    }

    T1 get1() {
        return self.value1;
    }

    T2 get2() {
        return self.value2;
    }

    T3 get3() {
        return self.value3;
    }

    T4 get4() {
        return self.value4;
    }

    T5 get5() {
        return self.value5;
    }

    T6 get6() {
        return self.value6;
    }

    T7 get7() {
        return self.value7;
    }

    TRest getRest() {
        return self.rest;
    }

    virtual bool operator==(Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> right) {
        return self.value1 == right.value1 && self.value2 == right.value2 && self.value3 == right.value3 && self.value4 == right.value4 && self.value5 == right.value5 && self.value6 == right.value6 && self.value7 == right.value7 && self.rest == right.rest;
    }
    virtual bool operator!=(Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> right) {
        return !(self == right);
    }

    virtual bool operator>(Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> right) {
        return self.value1 > right.value1;
    }
    virtual bool operator<(Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> right) {
        return self.value1 < right.value1;
    }
    virtual bool operator>=(Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> right) {
        return self > right || self == right;
    }
    virtual bool operator<=(Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> right) {
        return self < right || self == right;
    }

    virtual Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> clone() throws Exception{
        Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> new_tuple = new Tuple<T1, T2, T3, T4, T5, T6, T7, TRest>();

        new_tuple.set1(self.get1().clone());
        new_tuple.set2(self.get2().clone());
        new_tuple.set3(self.get3().clone());
        new_tuple.set4(self.get4().clone());
        new_tuple.set5(self.get5().clone());
        new_tuple.set6(self.get6().clone());
        new_tuple.set7(self.get7().clone());
        new_tuple.setRest(self.getRest().clone());

        return new_tuple;
    }

    virtual String toString() {
        return "{" + self.value1.toString() + ":" + self.value2.toString() + ":" + self.value3.toString() + ":" + self.value4.toString() + ":" + self.value5.toString() + ":" + self.value6.toString() + ":" + self.value7.toString() + ":" + self.rest.toString() + "}";
    }
    virtual int hashValue() {
        return self.value1.hashValue() ^ self.value2.hashValue() ^ self.value3.hashValue() ^ self.value4.hashValue() ^ self.value5.hashValue() ^ self.value6.hashValue() ^ self.value7.hashValue() ^ self.rest.hashValue();
    }
}

class Hash<K, V> implements ICloneable
{
    native Hash<K, V> setValue(Hash<K, V> value);
    native Hash<K, V> getValue();

    native V put(K key, V item);
    native V@CheckForNull get(K key);
    native int length();
    native Hash<K, V> each() with void block(K key, V value);

    V@CheckForNull operator[](K key) {
        return self.get(key);
    }

    V operator[]=(K key, V item) {
        return self.put(key, item);
    }

    Array<K> keys() {
        Array<K> array = new Array<K>();

        self.each() {|K key, V value| 
            array.add(key);
        }

        return array;
    }

    Array<V> values() {
        Array<V> array = new Array<V>();

        self.each() {|K key, V value| 
            array.add(value);
        }

        return array;
    }

    Array<Tuple<K,V>> toArray() {
        Array<Tuple<K,V>> array = new Array<Tuple<K,V>>();

        self.each() {|K key, V value|
            Tuple<K, V> tuple = new Tuple<K, V>();

            tuple.set1(key);
            tuple.set2(value);

            array.add(tuple);
        }

        return array;
    }

/*
    bool operator==(Hash<K,V> hash) {
        Array<Tuple<K,V>> left_array = self.toArray();
        Array<Tuple<K,V>> right_array = hash.toArray();

        return true;
    }
*/

    void clear() {
        self.setValue(new Hash<K,V>());
    }

    virtual Hash<K,V> clone() throws Exception {
        Hash<K,V> new_hash = new Hash<K,V>();
        new_hash.setValue(self);
        return new_hash;
    }
}

final class Thread implements ICloneable
{
    native void setValue(Thread value);
    native Thread() with void block() throws Exception;
    native void join();

    virtual Thread clone() throws Exception {
        Thread new_thread = new Thread();
        new_thread.setValue(self);
        return new_thread;
    }
}

final class Mutex implements ICloneable
{
    native void setValue(Mutex value);
    native Mutex();

    native void run() with void block();

    virtual Mutex clone() throws Exception {
        Mutex new_mutex = new Mutex();
        new_mutex.setValue(self);
        return new_mutex;
    }
}

/*
abstract class File 
{
    abstract void write(Bytes data) throws IOException, Exception;
    abstract Bytes read(int size) throws IOException;
}

class RegularFile extends File 
{
    native RegularFile(String file_name, String mode, int permission=0644) throws ConvertingStringCodeException, Exception, IOException;

    virtual native void write(Bytes data) throws IOException, Exception;
    virtual native Bytes read(int size) throws IOException;
}
*/

abstract final class Block 
{
}

/// user object class ///
final class GenericsParam0 {}   // for generics parametor
final class GenericsParam1 {}
final class GenericsParam2 {}
final class GenericsParam3 {}
final class GenericsParam4 {}
final class GenericsParam5 {}
final class GenericsParam6 {}
final class GenericsParam7 {}

final class Clover 
{
    alias print;
    alias println;

    native static void print(String string) throws NullPointerException, ConvertingStringCodeException;
    static void println(String string) {
        Clover.print(string + "\n");
    }
    native static void showClasses();
    native static String outputToString() with void block() throws ConvertingStringCodeException;

    /// called at the first part of runtime ///
    static bool initialize() {
        System.srand(System.time());

        return true;
    }
}

final class System 
{
    native static String getenv(String env) throws ConvertingStringCodeException;
    native static int sleep(int second) throws RangeException;
    native static void exit(int status_code) throws RangeException;
    native static int rand();
    native static void srand(int seed);
    native static int time();
//    native static void popen(String command) with void block(File file);
}

class Exception 
{
    protected String message;

    Exception(String message) {
        self.message = message;
    }

    String getMessage() {
        return self.message;
    }
}

class NullPointerException extends Exception 
{
    NullPointerException(String message) {
        self.message = message;
    }
}

class RangeException extends Exception 
{
    RangeException(String message) {
        self.message = message;
    }
}

class ConvertingStringCodeException extends Exception 
{
    ConvertingStringCodeException(String message) {
        self.message = message;
    }
}

class ClassNotFoundException extends Exception 
{
    ClassNotFoundException(String message) {
        self.message = message;
    }
}

class IOException extends Exception 
{
    IOException(String message) {
        self.message = message;
    }
}

class OverflowException extends Exception 
{
    OverflowException(String message) {
        self.message = message;
    }
}

class CantSolveGenericsType extends Exception 
{
    CantSolveGenericsType(String message) {
        self.message = message;
    }
}

class TypeError extends Exception 
{
    TypeError(String message) {
        self.message = message;
    }
}

class MethodMissingException extends Exception 
{
    MethodMissingException(String message) {
        self.message = message;
    }
}

class DivisionByZeroException extends Exception 
{
    DivisionByZeroException(String message) {
        self.message = message;
    }
}

class OverflowStackSizeException extends Exception 
{
    OverflowStackSizeException(String message) {
        self.message = message;
    }
}

class InvalidRegexException extends Exception 
{
    InvalidRegexException(String message) {
        self.message = message;
    }
}

/// interfaces ///
interface IComparable 
{
    bool operator==(anonymous right);
    bool operator!=(anonymous right);
}

interface IComparableMore extends IComparable 
{
    bool operator>(anonymous right);
    bool operator<(anonymous right);
    bool operator>=(anonymous right);
    bool operator<=(anonymous right);
}

interface IInspectable 
{
    String toString();
}

interface IHashKey 
{
    int hashValue();
}

interface ICloneable 
{
    anonymous clone() throws Exception;
}
