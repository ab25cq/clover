-+- 仕様 -+------------------------------------------------------
[オブジェクトを作成する手順]

1. createするオブジェクトは必ず一度ローカル変数に入れてください。

    CLObject obj;
    obj = create_bool_object(1);

2. 複数回オブジェクトを作成する時は、前に作成したオブジェクトはマークされるようにしないとダメです。スタックにpushするか、他のマークされるオブジェクトに格納するかしてください。スタックにpush後はマークされることが確定されれば、pop_objectしてください。マークされない状態でGCが動くと消えてしまいます。

    CLObject obj1, obj2;

    obj = create_bool_object(1);

    push_object(obj, info);        // -->マークのためスタックに退避しておく。(= objはマークされる)

    obj2 = create_bool_object(2);  // -->ここでGCが動く可能性がある。

    // obj2やobjを次回のGCが動くまで(オブジェクトを作成するときまで)にマークされる状態にする。

    pop_object(info);

    // obj2やobjを次回のGCが動くまで(オブジェクトを作成するときまで)にマークされる状態にする。


int型は32/64ビット. CPUのビット数依存。
Stringの1文字はwchar_t型。 Stringはwchar_tの配列として扱っている。
wchar_tはUTF-32らしい。(== 32ビット)
'a'1文字もint型として扱っている。

superはクラスメソッドには対応していない

ブロックにはresult typeを最初に書く。 --> 引数とフィールドの初期化でも使える。
int a = int {
    111;
}

void {
    Clover.println("HELLO BLOCK");
}

全てのクラスは参照型。

special class --> void, int, float, byte, bool, Null, Bytes, Array, Hash, String
どちらもフィールドが追加できない。
継承したクラスでもフィールドが追加できない。

すべてのクラスはopen class。フィールドとメソッドの追加に何の制限もない。追加する場合はmixin指定をclass名の最初につける。ただし、フィールドとメソッドのindexはコンパイル時に決まるので、追加した場合は既存のソースの再コンパイルが必要になることがある。その辺はユーザーが管理する。その代わりメソッドの探索はコンパイル時に決まるため、実行時には不要。polymophizmが必要な場合はvirtual指定して実行時にメソッド探索する。

クラスの参照はクラスファイル単位。includeは単に同一ファイルとして扱って同時にコンパイルするだけ。循環参照のためにある。クラスの依存関係は、ユーザーの管理。

ヒープに関する仕様。

ヒープからメモリを取り出し、あるマークされる変数に代入する前に、さらにヒープからメモリを取り出すと、最初のメモリが開放されてしまう。2度目以上のメモリを取り出す前に最初のメモリをpush_objectしてスタックに積む必要がある。後片付けとしてpop_objectも必要。

左辺にヒープのトップからのoffset、右辺にGC(realloc)が起こり得る関数がくる代入はC言語の仕様により、代入がおかしくなる。
一度右辺の値をCLObjectに代入してから左辺のoffset位置に代入する必要がある。
(今のところの仕様。GCを書き直して直るかもしれない)

newは引数なしなら、コンストラクタを定義していなくても呼べる。すべて0(Uninitialized)が入っている。

ヒープ(GCが走る可能性があるobjectの生成など)を使うところにはthreadのlockが必要。

オブジェクトが生成される関数のところではGCが動く可能性があるので、オブジェクトがオブジェクトを保持している場合、ちゃんとマークされるかされないかを意識しないといけない。
もし、どこからもマークされない場合、一時的にスタックにオブジェクトをpushしないといけない。

new自体できないし継承してもnewができないクラス --> mCreateFun = NULLのクラス。

src/obj_void.c:    klass->mCreateFun = NULL;
src/obj_anonymous.c:    klass->mCreateFun = NULL;
src/obj_type_object.c:    klass->mCreateFun = NULL;
src/obj_block.c:    klass->mCreateFun = NULL;

以下はNEW_OBJECTの命令があるため、mCreateFun = NULLでも継承してnewできるし、継承してもOK
src/obj_user_object.c:    klass->mCreateFun = NULL;

引数の型は静的に決まる。デフォルト引数があるので、そうするしかなかった。

dynamic_typingをつけたクラスはmethod callがダックタイピング。
全ての型のオブジェクトを代入できるし、また全ての型に代入することができる。
voidを返すmethodは初期化されていないオブジェクトを返す。

tryはローカル変数に3つのオブジェクトを作る。

1. try block object
2. catch block object
3. finally block object or int object

3はfinally blockがあるならブロックを無いならint objectを作る。
ローカル変数に保存しないとブロックオブジェクトがsweepにより削除されてしまうため。

try

    int a = int try { } finally { return 123; }

    catchは何個も重ねられる。finallyはあってもなくても良い。

    finallyには戻り値が設定できる。returnで返す。

normal block

    int a = int { 111; } などと書く

    最後に評価した値が戻り値 --> fieldの初期化、引数の初期化のために戻り値が返せる必要があり。

for,while,do,if

    戻り値は設定できない。--> できるようにしてもいいが、correct_stack_pointerとの兼ね合いがあるから、無理かもしれない。

ブロックの変数の扱いについて

    ブロックの開始時にその子ブロックで使っている全てのローカル変数もスタックに積んでいる。ブロックの終了時にPOPする必要はない。

ブロック付きメソッドのローカル変数について。

    親のスタックをコピーする。ブロックを抜けるときにまたコピーしなおす。

    親のローカル変数にアクセスするため。

    int a = 1;
    int b = 2;

    Clover.outputToSTring() {
        int c = 3;
        int d = 4;

        println(a.toString());    // --> アクセスできる。
        a = 777;                  // --> 代入もできる。
    }

println(a.toString());            // --> 777が表示される

ブロック付きメソッドのスタックについて

    引数1
    引数2
    引数3
    ブロック
    でコールされる。

    a.method(111, 222, 333) { |int a| }
    なら
    111
    222
    333
    ブロックオブジェクト

    とスタックにつまれて、メソッドコールが起きる。

for文のスタックについて

    int a = 1;
    int b = 2;
    for(i=0; i<5; i++) {
        int c = 3;
        int d = 4;
    }

    だと、
    a --> 1
    b --> 2
    i --> 0
    c --> 3
    d --> 4
    の5個の変数が宣言されて、スタックにつまれる。
    cへの代入はOP_STORE 3(変数の四番目)に入れられる。
    ブロック内の変数は親の環境からフラットにつまれていく。

メソッド呼び出しのスタックの使い方

    1. クラスメソッド(引数がある場合)

        引数が２つある場合は

        1. 引数1
        2. 引数2
        stack pointer --> 3. 

        でメソッドコールが起こる。

        ローカル変数が2つある場合は

        local var table top --> 1. 引数1
        2. 引数2
        3. ローカル変数1
        4. ローカル変数2
        stack pointer --> 5. ワークエリア1

        となる。

    2. メソッド(引数がある場合)

        コールする前

        2つ引数がある時は

        1. self
        2. 引数1
        3. 引数2
        stack pointer --> 4. 

        この状態でメソッドコールが起きる。

        コール後、ローカル変数が2つある場合

        local var tableのtop --> 1. self
        2. 引数1
        3. 引数2
        4. ローカル変数1
        5. ローカル変数2
        stack pointer --> 6. ワークエリア1

        となる。

    3. クラスメソッド（引数とブロックがある場合)

        引数が２つある場合

        1. 引数1
        2. 引数2
        3. ブロック
        stack pointer --> 4.

        でメソッドコールが起きる。

        メソッドコール後、２つローカル変数がある場合

        local var table top --> 1. 引数1
        2. 引数2
        3. ブロック
        4. ローカル変数1
        5. ローカル変数2
        stack pointer --> 6. ワークエリア

        となる。

    4. メソッド（引数とブロックがある場合)

        引数が2つある場合

        1. オブジェクト
        2. 引数1
        3. 引数2
        4. ブロック
        stack pointer --> 5.

        でメソッドコールが起きる。

        メソッドコール後、２つローカル変数がある場合

        local var table top --> 1. オブジェクト
        2. 引数1
        3. 引数2
        4. ブロック
        5. ローカル変数1
        6. ローカル変数2
        stack pointer --> 7. ワークエリア

        となる。

superの呼び出し時のスタックの使い方

    1. メソッド

        引数が2つある場合

        superが呼ばれる前は

        1. self
        2. 引数1
        3. 引数2
        stack pointer --> 4.

        ローカル変数が２つある場合は

        local var tableのtop --> 1. self
        2. 引数1
        3. 引数2
        4. ローカル変数1
        5. ローカル変数2
        stack pointer --> 6.

        となる。（普通のメソッドコールと同じ）


for,if,while,doなどのブロックでのローカル変数の扱い。

    int x = 789;
    int y = 012;

    for(int i=0; i<3; i++) {
        int k = 123;
        int j = 345;
    }

    for(int i=0; i<5; i++) {
        int l = 777;
    }

    ならローカル変数は5個用意される。
    1回目のiと2回目のiは同じ領域が使用される。
    int kとint lは同じ領域が使用される。
    ブロック内でしか変数はアクセスできない。

selfへの代入

    class Test {
        int field1;
        int field2;

        Test(int value, int value2) {
            self.field1 = value;
            self.field2 = value2;
        }

        void method() {
            self = new Test(111,222);
        }

        int getField1() { return self.field1; }
        int getField2() { return self.field2; }
    }

    a = new Test(333,444); a.method()してもaが変わるわけではない。
    できればいろいろと使いやすいのだが、、、、。

    void setValue(Test a) {
        self.field1 = a.field1;
        self.field2 = a.field2;
    }
    を作って値をコピーすれば、似たようなことはできる。

    copyメソッドを使うか？

    void method() {
        self.copy(new Test(111,222));
    }
    とすればselfへの代入は実現できる。

struct
    structは代入時にclone()を呼び出す。IClonableを実装しないといけない。
    メソッドの引数に代入する時もclone()を呼び出す。値渡しになる。

Call by refferce, Call by value

    structと普通のクラスには*をつけることができる。つけることによって
    structはリファレンス渡しに普通のクラスは値渡しになる。
    普通のクラスの値渡しにはcloneメソッドを実装する必要がある。無いとコンパイルエラーになる。
    int a = 123; int* b = a; b.setValue(345); // a --> 345 b --> 345
    String a = "ABC"; String* b= a; b.setValue("DEF"); // a --> "ABC" b --> "DEF"

-+- clover -+----------------------------------
clone methodのインデックスをコンパイル時に確定する。clone_methodの呼び出しが遅い。

Array<T>をmixinするとおかしい

Array<T>でTがstructでないためcloneが呼ばれていない。Array<int>の場合で。
solve_generics_types_for_node_typeを行う。

b.clc b.clを通す。clone_methodでsolve_generics_types_for_node_typeをするとエンバグする。
スタックを見てデバッグしないと原因が分からない。見ながらデバッグする。

Array.sortまで実装した。
array.sort() with blockをテストする。

Arrayクラスを実装する。

C-cで止めるとセグる。

special classにfieldを追加できるようにする。

Fileクラスはspecial classじゃなくてユーザークラスで実装する。
int FD;をフィールドに持つ。
open, closeはSystemクラスのクラスメソッドにする。システムコールはSystemクラスに実装する。
基本ライブラリを作っていく。

a.clを通す
Array.includeで==でint.operator == が呼ばれないとダメなのにObject.operator ==が呼ばれている。
array.includeでArray<int>がincludeの中に渡されていない。
src/klass.cの不具合。Array<T>がvm_type

Fileクラスはユーザークラスにする。specialじゃなくても実装できる。

Array, List, Hashの実装。genericsのテスト。Array<Array<String>>など再起構造にも対応。

Hashがまだ全然コーディングできていない。
src/vm.cのNEW_HASHなど。

ブロックの戻り値はbreakで返した方が良くないか？
String str = String { int a = 0; a++; break "AAA" };
今だとString str = String { "AAA" };となっている

ヒープをページ単位に書き直す。ページのサイズを越えるときは単にCALLOCする。
今のままだだとヒープのoffsetが左辺値、reallocが起こり得る関数が右辺値にくる代入文がおかしくなる。

File, RegularFileの実装。file.clを通す

String.to_int(); String.to_float();

FieldInitializerのリファクタリング。もっと簡単にできる。

RegularFileクラス、Fileクラスの実装。

File.FileのモードにO_WRONLYなども指定できるように
File(String file_name, int mode);
のコンストラクタも作る。

pipeout, pipeinで外部プログラムと連携

文字列処理を入れる。
string_appendの実装。stringの仕様を変える。文字列を伸ばせるようにする。

mixinとsuperのgenerics対応とテスト。

Mutexのテスト

ユーザーのオリジナルスペシャルクラスを作る場合、native methodの登録をどうするか。動的ライブラリを使うか。

Clover.class_dependences(MyClass); 
クラスの依存クラスを文字列の配列で返す。クラスオブジェクトは無し。クラスは文字列で表す

Clover.class_file_path(MyClass); クラスファイルの絶対パスを返す

引数数-1の処理をちゃんとする。printfもできるようにちゃんとする。
Clover.printf

generics未実装なもの
    定数の引数
    methodスコープのgenerics
    generics型同士の代入。ワイルドカード<? super ClassA>など。

compiler.cでパースのエラー処理、expect系が不完全。少し予想外が起こるとエラー出力が滅茶苦茶になる。

privateクラスの実装、compiler.cはできている。namespace内でしか使えないクラス。

GCの改良。毎回コンパクションはしない
世代別GC

special classesもfieldの追加ができるようにする？できなくもない、、、。
Array, String, Hashもフィールドを追加できるようにする。Array, String, Hashの子クラスでフィールドを追加したい。

voidの戻り値は全て未定義のオブジェクトでいいのでは？リファクタリング。
