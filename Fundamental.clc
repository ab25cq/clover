
/// interfaces ///
interface IComparable {
    bool operator==(anonymous right);
    bool operator!=(anonymous right);
}

interface IComparableMore extends IComparable {
    bool operator>(anonymous right);
    bool operator<(anonymous right);
    bool operator>=(anonymous right);
    bool operator<=(anonymous right);
}

interface IClonable {
    anonymous clone();
}

interface IInspectable {
    String toString();
}

/// special classes ///
class Object {
    native Type type() throws ConvertingStringCodeException;
    native int ID();
    native bool isUninitialized();

    // native void setType(Type type);

    bool instanceOf(Type type_object) {
        return self.type() == type_object;
    }
    bool isChild(Type type_object) {
        Type it = self.type();
        while(it != null) {
            if(it == type_object) {
                return true;
            }
            it = it.parentClass();
        }

        return false;
    }

    bool operator == (Null value) {
        return self.type() == Null;
    }
    bool operator != (Null value) {
int a = new int(5);
        return !(self == value);
    }
    Null toNull() throws TypeError {
        if(self.type() == Null) {
            return self;
        }
        else {
            throw new TypeError("type error");
        }
    }
}

final class Type implements IComparable, IInspectable {
    native String toString();
    native bool equals(Type value);

    native Type class();
    native Type genericsParam(int index);
    native int genericsParamNumber();
    native Type parentClass();
    native int parentClassNumber();

    bool operator ==(Type value) {
        return self.equals(value);
    }
    bool operator !=(Type value) {
        return !(self == value);
    }
    Type operator [](int index) {
        return self.genericsParam(index);
    }
}

dynamic_typing final class anonymous {
}

final class void {
}

dynamic_typing final class Null implements IComparable, IInspectable {
    Null() {
    }

    int toInt() {
        return 0;
    }
    String toString() {
        return "null";
    }
    bool toBool() {
        return false;
    }

    bool operator ==(anonymous value) {
        return value.type() == Null;
    }
    bool operator !=(anonymous value) {
        return !(self == value);
    }
}

struct int implements IComparable, IClonable, IInspectable {
    native String toString();
    native byte toByte(); // throws OverflowException;
    native float toFloat(); 

    native int setValue(int value);
    native int getValue();

    int clone() {
        int new_object = new int();
        new_object.setValue(self);
        return new_object;
    }

    bool toBool() {
        return self != 0;
    }

    generics_newable int(int value) {
        self.setValue(value);
    }

    int operator ++() {
        self.setValue(self + 1);
        return self;
    }
    int operator ++2() {
        self.setValue(self + 1);
        return self -1;
    }
    int operator --() {
        self.setValue(self - 1);
        return self;
    }
    int operator --2() {
        self.setValue(self - 1);
        return self + 1;
    }
    int operator +=(int value) {
        return self \+= value;
    }
    int operator -=(int value) {
        return self \-= value;
    }
    int operator *=(int value) {
        return self \*= value;
    }
    int operator /=(int value) {
        return self \/= value;
    }
    int operator %=(int value) {
        return self \%= value;
    }
    int operator <<=(int value) {
        return self \<<= value;
    }
    int operator >>=(int value) {
        return self \>>= value;
    }
    int operator &=(int value) {
        return self \&= value;
    }
    int operator ^=(int value) {
        return self \^= value;
    }
    int operator |=(int value) {
        return self \|= value;
    }
    int operator +(int value) {
        return self \+ value;
    }
    int operator -(int value) {
        return self \- value;
    }
    int operator *(int value) {
        return self \* value;
    }
    int operator %(int value) {
        return self \% value;
    }
    int operator /(int value) {
        return self \/ value;
    }
    int operator <<(int value) {
        return self \<< value;
    }
    int operator >>(int value) {
        return self \>> value;
    }
    bool operator ==(int value) {
        return self \== value;
    }
    bool operator !=(int value) {
        return self \!= value;
    }
    bool operator <(int value) {
        return self \< value;
    }
    bool operator <=(int value) {
        return self \<= value;
    }
    bool operator >(int value) {
        return self \> value;
    }
    bool operator >=(int value) {
        return self \>= value;
    }
    int operator &(int value) {
        return self \& value;
    }
    int operator ^(int value) {
        return self \^ value;
    }
    int operator |(int value) {
        return self \| value;
    }
    int operator ~() {
        return \~self;
    }
}

struct float implements IComparable, IInspectable, IClonable { 
    native int toInt();
    native String toString();

    native float setValue(float value);
    native float getValue();

    generics_newable float(float value) {
        self.setValue(value);
    }

    float clone() {
        float new_object = new float();
        new_object.setValue(self);
        return new_object;
    }

    float operator ++() {
        self.setValue(self + 1.toFloat());
        return self;
    }
    float operator ++2() {
        self.setValue(self + 1.toFloat());
        return self -1.toFloat();
    }
    float operator --() {
        self.setValue(self - 1.toFloat());
        return self;
    }
    float operator --2() {
        self.setValue(self - 1.toFloat());
        return self + 1.toFloat();
    }
    float operator +=(float value) {
        return self \+= value;
    }
    float operator -=(float value) {
        return self \-= value;
    }
    float operator *=(float value) {
        return self \*= value;
    }
    float operator /=(float value) {
        return self \/= value;
    }
    float operator +(float value) {
        return self \+ value;
    }
    float operator -(float value) {
        return self \- value;
    }
    float operator *(float value) {
        return self \* value;
    }
    float operator /(float value) {
        return self \/ value;
    }
    bool operator ==(float value) {
        return self \== value;
    }
    bool operator !=(float value) {
        return self \!= value;
    }
    bool operator <(float value) {
        return self \< value;
    }
    bool operator <=(float value) {
        return self \<= value;
    }
    bool operator >(float value) {
        return self \> value;
    }
    bool operator >=(float value) {
        return self \>= value;
    }
}

struct byte implements IComparable, IInspectable, IClonable {
    native String toString();
    native int toInt();

    native byte setValue(byte value);
    native byte getValue();

    generics_newable byte(byte value) {
        self.setValue(value);
    }

    byte clone() {
        byte new_object = new byte();
        new_object.setValue(self);
        return new_object;
    }

    byte operator ++() {
        self.setValue(self + 1.toByte());
        return self;
    }
    byte operator ++2() {
        self.setValue(self + 1.toByte());
        return self - 1.toByte();
    }
    byte operator --() {
        self.setValue(self - 1.toByte());
        return self;
    }
    byte operator --2() {
        self.setValue(self - 1.toByte());
        return self + 1.toByte();
    }
    byte operator +=(byte value) {
        return self \+= value;
    }
    byte operator -=(byte value) {
        return self \-= value;
    }
    byte operator *=(byte value) {
        return self \*= value;
    }
    byte operator /=(byte value) {
        return self \/= value;
    }
    byte operator %=(byte value) {
        return self \%= value;
    }
    byte operator <<=(byte value) {
        return self \<<= value;
    }
    byte operator >>=(byte value) {
        return self \>>= value;
    }
    byte operator &=(byte value) {
        return self \&= value;
    }
    byte operator ^=(byte value) {
        return self \^= value;
    }
    byte operator |=(byte value) {
        return self \|= value;
    }
    byte operator +(byte value) {
        return self \+ value;
    }
    byte operator -(byte value) {
        return self \- value;
    }
    byte operator *(byte value) {
        return self \* value;
    }
    byte operator %(byte value) {
        return self \% value;
    }
    byte operator /(byte value) {
        return self \/ value;
    }
    byte operator <<(byte value) {
        return self \<< value;
    }
    byte operator >>(byte value) {
        return self \>> value;
    }
    bool operator ==(byte value) {
        return self \== value;
    }
    bool operator !=(byte value) {
        return self \!= value;
    }
    bool operator <(byte value) {
        return self \< value;
    }
    bool operator <=(byte value) {
        return self \<= value;
    }
    bool operator >(byte value) {
        return self \> value;
    }
    bool operator >=(byte value) {
        return self \>= value;
    }
    byte operator &(byte value) {
        return self \& value;
    }
    byte operator ^(byte value) {
        return self \^ value;
    }
    byte operator |(byte value) {
        return self \| value;
    }
    byte operator ~() {
        return \~self;
    }
}

struct bool implements IComparable, IInspectable, IClonable {
    native bool setValue(bool value);
    native bool getValue();

    generics_newable bool(bool value) {
        self.setValue(value);
    }

    bool clone() {
        bool new_object = new bool();
        new_object.setValue(self);
        return new_object;
    }

    String toString() {
        if(self) {
            return "true";
        }
        else {
            return "false";
        }
    }
    int toInt() {
        if(self) {
            return 1;
        }
        else {
            return 0;
        }
    }
    
    bool operator !() {
        return \!self;
    }
    bool operator &&(bool value) {
        return self \&& value;
    }
    bool operator ||(bool value) {
        return self \|| value;
    }

    bool operator ==(bool value) {
        return self \== value;
    }
    bool operator !=(bool value) {
        return self \!= value;
    }
}

class String implements IComparable, IInspectable, IClonable {
    native String setValue(String value);
    native String getValue();

    String clone() {
        String new_string = new String();
        new_string.setValue(self);
        return new_string;
    }

    native int length();

    native int char(int index) throws RangeException;

    native int replace(int index, int character) throws RangeException;

    native Bytes toBytes() throws ConvertingStringCodeException;

    generics_newable String(String value) {
        self.setValue(value);
    }

    void print() {
        Clover.print(self);
    }
    void println() {
        Clover.println(self);
    }

    int operator[] (int index) throws RangeException {
        return self.char(index);
    }

    int operator[]= (int index, int character) throws RangeException {
        return self.replace(index, character);
    }

    String operator+= (String string) {
        self.setValue(self + string);
        return self;
    }

    bool operator==(String right) {
        return (self \== right);
    }
    bool operator!=(String right) {
        return !(self \== right);
    }

    String operator +(String value) {
        return self \+ value;
    }

    String toString() { return self }
}

class Bytes implements IInspectable {
    native String toString();
    native int length();
    native byte replace(int index, byte c);
    native byte char(int index) throws RangeException;

    native Bytes setValue(Bytes value);
    native Bytes getValue();

    generics_newable Bytes(Bytes value) {
        self.setValue(value);
    }

    byte operator[]= (int index, byte c) {
        return self.replace(index, c);
    }
    byte operator[] (int index) throws RangeException {
        return self.char(index);
    }

    bool operator==(Bytes right) {
        return (self \== right);
    }
    bool operator!=(Bytes right) {
        return !(self \== right);
    }

    Bytes operator +(Bytes value) {
        return self \+ value;
    }
}

class Range implements IComparable, IInspectable {
    native int head();
    native int tail();

    bool operator==(Range range) {
        return self.head() == range.head() && self.tail() == range.tail();
    }

    bool operator!=(Range range) {
        return !(self == range);
    }

    bool include(int number) {
        return number >= self.head() && number <= self.tail();
    }

    String toString() {
        return self.head().toString() + ".." + self.tail().toString();
    }
}

class Array<T implements IComparable&IInspectable&IClonable> implements IComparable, IInspectable, IClonable
{
    native Array<T> setValue(Array<T> value);
    native Array<T> getValue();

    native void add(T item);
    native T items(int index) throws RangeException;
    native int length();
    native T setItem(int index, T item) throws RangeException;

    Array<T> clone() {
        Array<T> new_array = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            new_array.add(self.items(i).clone());
        }

        return new_array;
    }

    T items(int index, T default) {
        int index2 = index;

        if(index2 < 0) {
            index2 += self.length();
        }

        if(index2 < 0 || index2 >= self.length()) {
            return default;
        }

        return self.items(index);
    }

    T items(int index) with T block(int index) {
        int index2 = index;

        if(index2 < 0) {
            index2 += self.length();
        }

        if(index2 < 0 || index2 >= self.length()) {
            return block(index2);
        }
    
        return self.items(index);
    }

    T find(int find_count=1) with bool block(T item) {
        int count = 0;
        for(int i=0; i<self.length(); i++) {
            if(block(self.items(i))) {
                count++;
                if(count == find_count) {
                    return self.items(i);
                }
            }
        }

        return null;
    }

    T operator[] (int index) throws RangeException {
        return self.items(index);
    }

    T operator[]= (int index, T item) throws RangeException {
        return self.setItem(index, item);
    }

    bool empty() {
        return self.length() == 0;
    }

    T deleteAt(int number) {
        T result = null;
        Array<T> new_array = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            if(i == number) {
                result = self.items(i);
            }
            else {
                new_array.add(self.items(i));
            }
        }

        self.setValue(new_array);

        return result;
    }

    T first() {
        return self.items(0);
    }

    T last() {
        return self.items(self.length()-1);
    }

    T pop() {
        if(self.length() == 0) {
            return null;
        }

        Array<T> new_array = new Array<T>();
        T result = self.items(self.length()-1);

        for(int i=0; i<self.length()-1; i++) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return result;
    }
    Array(Array<T> array) {
        self.setValue(array);
    }

    bool include(T item) {
        for(int i=0; i<self.length(); i++) {
            if(self.items(i) == item) {
                return true;
            }
        }

        return false;
    }

    int count(T item) {
        int c = 0;

        for(int i=0; i<self.length(); i++) {
            if(self.items(i) == item) {
                c++;
            }
        }

        return c;
    }

    bool operator==(Array<T> array2) {
        if(self.length() != array2.length()) {
            return false;
        }

        for(int i=0; i<self.length(); i++) {
            if(self[i] != array2[i]) {
                return false;
            }
        }

        return true;
    }
    bool operator!=(Array<T> array2) {
        return !(self == array2);
    }

    T delete(T item) {
        T result = null;

        Array<T> new_array = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            if(self.items(i) != item) {
                new_array.add(self.items(i));
            }
            else {
                result = self.items(i);
            }
        }

        self.setValue(new_array);

        return result;
    }

    int findIndex(T item, int count=1) {
        int c = 0;

        for(int i=0; i<self.length(); i++) {
            if(self.items(i) == item) {
                c++;

                if(c == count) {
                    return i;
                }
            }
        }

        return -1;
    }

    int findIndex(int count=1) with bool block(T item) {
        int c = 0;

        for(int i=0; i<self.length(); i++) {
            if(block(self.items(i))) {
                c++;

                if(c == count) {
                    return i;
                }
            }
        }

        return -1;
    }

    Array<T> operator+(Array<T> array2) {
        Array<T> result = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            result.add(self.items(i));
        }

        for(int i=0; i<array2.length(); i++) {
            result.add(array2.items(i));
        }

        return result;
    }

    String toString() {
        String result = "{";

        for(int i=0; i<self.length(); i++) {
            if(i == self.length()-1) {
                result += self.items(i).toString();
            }
            else {
                result += self.items(i).toString();
                result += ",";
            }
        }

        result += "}";

        return result;
    }

    String join(String separator="") {
        String result = "";

        for(int i=0; i<self.length(); i++) {
            if(i == self.length()-1) {
                result += self.items(i).toString();
            }
            else {
                result += self.items(i).toString();
                result += separator;
            }
        }

        return result;
    }

    int rindex(T item, int count=1) {
        int c = 0;
        for(int i=self.length()-1; i>=0; i--) {
            if(self.items(i) == item) {
                c++;

                if(c == count) {
                    return i;
                }
            }
        }

        return -1;
    }

    int rindex(int count=1) with bool block(T item) {
        int c = 0;
        for(int i=self.length()-1; i>=0; i--) {
            if(block(self.items(i))) {
                c++;

                if(c == count) {
                    return i;
                }
            }
        }

        return -1;
    }

    Array<T> each() with void block(T item) {
        for(int i=0; i<self.length(); i++) {
            block(self.items(i));
        }

        return self;
    }
    Array<T> eachWithIndex() with void block(T item, int index) {
        for(int i=0; i<self.length(); i++) {
            block(self.items(i), i);
        }

        return self;
    }
    Array<T> clear() {
        self.setValue(new Array<T>());
        return self;
    }

    Array<anonymous> collect() with anonymous block(T item) {
        Array<anonymous> new_array = new Array<anonymous>();

        for(int i=0; i<self.length(); i++) {
            new_array.add(block(self.items(i)));
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> concat(Array<T> array) {
        for(int i=0; i<array.length(); i++) {
            self.add(array.items(i));
        }

        return self;
    }

    Array<T> cycle(int number) with void block(T item) {
        for(int i=0; i<number; i++) {
            for(int j=0; j<self.length(); j++) {
                block(self.items(j));
            }
        }

        return self;
    }

    Array<T> deleteIf() with bool block(T item) {
        Array<T> new_array = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            if(!block(self.items(i))) {
                new_array.add(self.items(i));
            }
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> drop(int number) {
        Array<T> new_array = new Array<T>();

        for(int i=number; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> dropWhile() with bool block(T item) {
        Array<T> new_array = new Array<T>();
        bool addition = false;

        for(int i=0; i<self.length(); i++) {
            if(!addition && !block(self.items(i))) {
                addition = true;
            }

            if(addition) {
                new_array.add(self.items(i));
            }
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> eachIndex() with void block(int index) {
        for(int i=0; i<self.length(); i++) {
            block(i);
        }

        return self;
    }

    Array<T> fill(T item) {
        for(int i=0; i<self.length(); i++) {
            self.setItem(i, item);
        }

        return self;
    }

    Array<T> fill() with T block(int index) {
        for(int i=0; i<self.length(); i++) {
            self.setItem(i, block(i));
        }

        return self;
    }

    Array<T> fill(T item, Range range) throws RangeException{
        int head = range.head();
        int tail = range.tail();

        if(head < 0) {
            head += self.length();
        }

        if(tail < 0) {
            tail += self.length();
        }

        if(head < 0 || head >= self.length()) {
            throw new RangeException("Range Exception");
        }

        if(tail < 0 || tail >= self.length()) {
            throw new RangeException("Range Exception");
        }

        for(int i=head; i<=tail; i++) {
            self.setItem(i, item);
        }

        return self;
    }

    Array<T> fill(Range range) with T block(int index) throws RangeException{
        int head = range.head();
        int tail = range.tail();

        if(head < 0) {
            head += self.length();
        }

        if(tail < 0) {
            tail += self.length();
        }

        if(head < 0 || head >= self.length()) {
            throw new RangeException("Range Exception");
        }

        if(tail < 0 || tail >= self.length()) {
            throw new RangeException("Range Exception");
        }

        for(int i=head; i<=tail; i++) {
            self.setItem(i, block(i));
        }

        return self;
    }

    Array<T> first(int num) throws RangeException {
        Array<T> new_array = new Array<T>();

        if(num < 0 || num >= self.length()) {
            throw new RangeException("Range Exception");
        }

        for(int i=0; i<num; i++) {
            new_array.add(self.items(i));
        }

        return new_array;
    }

    Array<T> insert(int index, T item) throws RangeException {
        Array<T> new_array = new Array<T>();

        if(index < 0) {
            index += self.length();
        }

        if(index < 0 || index >= self.length()) {
            throw new RangeException("RangeException");
        }

        for(int i=0; i<index; i++) {
            new_array.add(self.items(i));
        }

        new_array.add(item);

        for(int i=index; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> insert(int index, Array<T> array) throws RangeException {
        Array<T> new_array = new Array<T>();

        if(index < 0) {
            index += self.length();
        }

        if(index < 0 || index >= self.length()) {
            throw new RangeException("RangeException");
        }

        for(int i=0; i<index; i++) {
            new_array.add(self.items(i));
        }

        for(int i=0; i<array.length(); i++) {
            new_array.add(array.items(i));
        }

        for(int i=index; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> keepIf() with bool block(T item) {
        Array<T> new_array = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            if(block(self.items(i))) {
                new_array.add(self.items(i));
            }
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> last(int num) {
        Array<T> new_array = new Array<T>();

        for(int i=self.length()-num; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        return new_array;
    }
    Array<T> pop(int num) {
        if(self.length() == 0) {
            return null;
        }

        Array<T> new_array = new Array<T>();
        Array<T> new_array2 = new Array<T>();

        for(int i=0; i<self.length(); i++) {
            if(i < self.length()-num) {
                new_array.add(self.items(i));
            }
            else {
                new_array2.add(self.items(i));
            }
        }

        self.setValue(new_array);

        return new_array2;
    }

    Array<T> push(T item) {
        self.add(item);
        return self;
    }

    Array<T> reverse() {
        Array<T> new_array = new Array<T>();

        for(int i=self.length()-1; i>=0; i--) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> rotate(int num) throws RangeException {
        Array<T> new_array = new Array<T>();

        if(num < 0) {
            for(int i=self.length()+num; i<self.length(); i++) {
                new_array.add(self.items(i));
            }
            for(int i=0; i<self.length()+num; i++) {
                new_array.add(self.items(i));
            }
        }
        else if(num == 0) {
            new_array.setValue(self);
        }
        else {
            for(int i=num; i<self.length(); i++) {
                new_array.add(self.items(i));
            }
            for(int i=0; i<num; i++) {
                new_array.add(self.items(i));
            }
        }

        self.setValue(new_array);

        return self;
    }

    T sample() {
        int index = System.rand() % self.length();

        return self.items(index);
    }

    Array<T> sample(int num) {
        Array<T> new_array = new Array<T>();

        for(int i=0; i<num; i++) {
            int index = System.rand() % self.length();

            new_array.add(self.items(index));
        }

        return new_array;
    }

    T shift() {
        Array<T> new_array = new Array<T>();

        T result = self.items(0);

        for(int i=1; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return result;
    }

    Array<T> shift(int num) {
        Array<T> new_array = new Array<T>();

        Array<T> result = new Array<T>();

        for(int i=0; i<num; i++) {
            result.add(self.items(i));
        }

        for(int i=num; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return result;
    }

    Array<T> unshift(T item) {
        Array<T> new_array = new Array<T>();

        new_array.add(item);

        for(int i=0; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> unshift(Array<T> array) {
        Array<T> new_array = new Array<T>();

        for(int i=0; i<array.length(); i++) {
            new_array.add(array.items(i));
        }

        for(int i=0; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> shuffle() {
        Array<T> new_array = new Array<T>();

        Array<int> squence = new Array<int>();

        for(int i=0; i<self.length(); i++) {
            squence.add(i);
        }

        for(int i=0; i<self.length() * 2; i++) {
            int num = System.rand() % self.length();
            int num2 = System.rand() % self.length();

            if(num != num2) {
                int temp = squence[num];
                squence[num] = squence[num2];
                squence[num2] = temp;
            }
        }

        for(int i=0; i<self.length(); i++) {
            new_array.add(self.items(squence[i]));
        }

        self.setValue(new_array);

        return self;
    }

    Array<T> slice(Range range) throws RangeException {
        Array<T> result = new Array<T>();

        for(int i=range.head(); i<=range.tail(); i++) {
            result.add(self.items(i));
        }

        return result;
    }

    Array<T> operator[](Range range) throws RangeException {
        return self.slice(range);
    }
}

class SortableArray <T implements IComparableMore&IInspectable&IClonable> extends Array<T> implements IComparable, IInspectable, IClonable
{
    SortableArray(Array<T> array) {
        self.setValue(array);
    }

    SortableArray<T> clone() {
        Array<T> new_array = new SortableArray<T>();

        for(int i=0; i<self.length(); i++) {
            new_array.add(self.items(i));
        }

        return new_array;
    }

    private void quickSort(Array<T> array, int left, int right) {
        int l_hold = left;
        int r_hold = right;

        T pivot = array[left];
        int pivot_num = left;

        while(left < right) {
            while((array[right] >= pivot) && (left < right)) {
                right--;
            }

            if(left != right) {
                array[left] = array[right];
                left++;
            }

            while((array[left] <= pivot) && (left < right)) {
                left++;
            }

            if(left != right) {
                array[right] = array[left];
                right--;
            }
        }

        array[left] = pivot;

        pivot_num = left;

        left = l_hold;
        right = r_hold;
        if(left < pivot_num) {
            self.quickSort(array, left, pivot_num-1);
        }

        if(right > pivot_num) {
            self.quickSort(array, pivot_num+1, right);

        }
    }

    SortableArray<T> sort() {
        SortableArray<T> array = self.clone();
        
        array.quickSort(array, 0, self.length()-1);

        self.setValue(array);

        return self;
    }

    private void quickSortWithBlock(Array<T> array, int left, int right) with int block(T item, T item2) 
    {
        int l_hold = left;
        int r_hold = right;

        T pivot = array[left];
        int pivot_num = left;

        while(left < right) {
            int result = block(array[right], pivot);

            while(result == 1 && (left < right)) {
                right--;
            }

            if(left != right) {
                array[left] = array[right];
                left++;
            }

            int result2 = block(array[left], pivot);
            while(result == -1 && (left < right)) {
                left++;
            }

            if(left != right) {
                array[right] = array[left];
                right--;
            }
        }

        array[left] = pivot;

        pivot_num = left;

        left = l_hold;
        right = r_hold;
        if(left < pivot_num) {
            self.quickSort(array, left, pivot_num-1);
        }

        if(right > pivot_num) {
            self.quickSort(array, pivot_num+1, right);

        }
    }

    SortableArray<T> sort() with int block(T item, T item2) {
        SortableArray<T> array = self.clone();
        
        array.quickSortWithBlock(array, 0, self.length()-1) with block;

        self.setValue(array);

        return self;
    }
}

class Hash<T> {
    //native Hash<T> setValue(Hash<T> value);
    //native Hash<T> getValue();
}

final class Thread {
    native Thread() with void block() throws Exception;
    native void join();
}

final class Mutex {
    native Mutex();

    native void run() with void block();
}

abstract class File {
    abstract void write(Bytes data) throws IOException, Exception;
    abstract Bytes read(int size) throws IOException;
}

class RegularFile extends File {
    native RegularFile(String file_name, String mode, int permission=0644) throws ConvertingStringCodeException, Exception, IOException;

    virtual native void write(Bytes data) throws IOException, Exception;
    virtual native Bytes read(int size) throws IOException;
}

final class Block {
}

/// user object class ///
final class GenericsParam0 {}   // for generics parametor
final class GenericsParam1 {}
final class GenericsParam2 {}
final class GenericsParam3 {}
final class GenericsParam4 {}
final class GenericsParam5 {}
final class GenericsParam6 {}
final class GenericsParam7 {}

final class Clover {
    alias print;
    alias println;

    native static void print(String string) throws NullPointerException, ConvertingStringCodeException;
    static void println(String string) {
        Clover.print(string + "\n");
    }
    native static void showClasses();
    native static String outputToString() with void block() throws ConvertingStringCodeException;

    /// called at the first part of runtime ///
    static bool initialize() {
        System.srand(System.time());

        return true;
    }
}

final class System {
    native static String getenv(String env) throws ConvertingStringCodeException;
    native static int sleep(int second) throws RangeException;
    native static void exit(int status_code) throws RangeException;
    native static int rand();
    native static void srand(int seed);
    native static int time();
//    native static void popen(String command) with void block(File file);
}

class Exception {
    protected String message;

    Exception(String message) {
        self.message = message;
    }

    String getMessage() {
        return self.message;
    }
}

class NullPointerException extends Exception {
    NullPointerException(String message) {
        self.message = message;
    }
}

class RangeException extends Exception {
    RangeException(String message) {
        self.message = message;
    }
}

class ConvertingStringCodeException extends Exception {
    ConvertingStringCodeException(String message) {
        self.message = message;
    }
}

class ClassNotFoundException extends Exception {
    ClassNotFoundException(String message) {
        self.message = message;
    }
}

class IOException extends Exception {
    IOException(String message) {
        self.message = message;
    }
}

class OverflowException extends Exception {
    OverflowException(String message) {
        self.message = message;
    }
}

class CantSolveGenericsType extends Exception {
    CantSolveGenericsType(String message) {
        self.message = message;
    }
}

class TypeError extends Exception {
    TypeError(String message) {
        self.message = message;
    }
}

class MethodMissingException extends Exception {
    MethodMissingException(String message) {
        self.message = message;
    }
}

class DivisionByZeroException extends Exception {
    DivisionByZeroException(String message) {
        self.message = message;
    }
}

class OverflowStackSizeException extends Exception {
    OverflowStackSizeException(String message) {
        self.message = message;
    }
}
